From 8c203eae1e90f646a3c7c40d9700d55de2163df1 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sat, 20 Apr 2013 11:51:58 -0400
Subject: [PATCH 01/53] make dynamic linker accept : or \n as path separator

this allows /etc/ld-musl-$(ARCH).path to contain one path per line,
which is much more convenient for users than the :-delimited format,
which was a source of repeated and unnecessary confusion. for
simplicity, \n is also accepted in environment variables, though it
should probably not be used there.

at the same time, issues with overly long paths invoking UB or getting
truncated have been fixed. such issues should not have arisen with the
environment (which is size-limited) but could have been generated by a
path file larger than 2**31 bytes in length.
---
 src/ldso/dynlink.c |   16 ++++++++--------
 1 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/src/ldso/dynlink.c b/src/ldso/dynlink.c
index efbec8f..dec9511 100644
--- a/src/ldso/dynlink.c
+++ b/src/ldso/dynlink.c
@@ -403,16 +403,16 @@ error:
 	return 0;
 }
 
-static int path_open(const char *name, const char *search, char *buf, size_t buf_size)
+static int path_open(const char *name, const char *s, char *buf, size_t buf_size)
 {
-	const char *s=search, *z;
-	int l, fd;
+	size_t l;
+	int fd;
 	for (;;) {
-		while (*s==':') s++;
-		if (!*s) return -1;
-		z = strchr(s, ':');
-		l = z ? z-s : strlen(s);
-		snprintf(buf, buf_size, "%.*s/%s", l, s, name);
+		s += strspn(s, ":\n");
+		l = strcspn(s, ":\n");
+		if (l-1 >= INT_MAX) return -1;
+		if (snprintf(buf, buf_size, "%.*s/%s", (int)l, s, name) >= buf_size)
+			continue;
 		if ((fd = open(buf, O_RDONLY|O_CLOEXEC))>=0) return fd;
 		s += l;
 	}
-- 
1.7.2.5


From 876464622fedd4dceb25700a04a881827d05d02d Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sat, 20 Apr 2013 14:01:33 -0400
Subject: [PATCH 02/53] clarify that bits headers are included as public headers

---
 COPYRIGHT |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/COPYRIGHT b/COPYRIGHT
index c081761..2f14e5f 100644
--- a/COPYRIGHT
+++ b/COPYRIGHT
@@ -78,12 +78,12 @@ All other files which have no copyright comments are original works
 Copyright © 2005-2012 Rich Felker, the main author of this library.
 The decision to exclude such comments is intentional, as it should be
 possible to carry around the complete source code on tiny storage
-media. All public header files (include/*) should be treated as Public
-Domain as they intentionally contain no content which can be covered
-by copyright. Some source modules may fall in this category as well.
-If you believe that a file is so trivial that it should be in the
-Public Domain, please contact me and, if I agree, I will explicitly
-release it from copyright.
+media. All public header files (include/* and arch/*/bits/*) should be
+treated as Public Domain as they intentionally contain no content
+which can be covered by copyright. Some source modules may fall in
+this category as well. If you believe that a file is so trivial that
+it should be in the Public Domain, please contact me and, if I agree,
+I will explicitly release it from copyright.
 
 The following files are trivial, in my opinion not copyrightable in
 the first place, and hereby explicitly released to the Public Domain:
-- 
1.7.2.5


From a896e893261544b523cef56d328546fbbaacfc99 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sat, 20 Apr 2013 14:02:55 -0400
Subject: [PATCH 03/53] update copyright year

---
 COPYRIGHT |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/COPYRIGHT b/COPYRIGHT
index 2f14e5f..09beea2 100644
--- a/COPYRIGHT
+++ b/COPYRIGHT
@@ -1,6 +1,6 @@
 musl as a whole is licensed under the following standard MIT license:
 
-Copyright © 2005-2012 Rich Felker
+Copyright © 2005-2013 Rich Felker
 
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
@@ -75,7 +75,7 @@ and later supplemented and integrated by John Spencer. It is licensed
 under the standard MIT terms.
 
 All other files which have no copyright comments are original works
-Copyright © 2005-2012 Rich Felker, the main author of this library.
+Copyright © 2005-2013 Rich Felker, the main author of this library.
 The decision to exclude such comments is intentional, as it should be
 possible to carry around the complete source code on tiny storage
 media. All public header files (include/* and arch/*/bits/*) should be
-- 
1.7.2.5


From 5d37b79793b17edcc6fe71b8a7de318276904fd8 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sat, 20 Apr 2013 14:03:12 -0400
Subject: [PATCH 04/53] mention bits headers in another part of copyright file

---
 COPYRIGHT |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/COPYRIGHT b/COPYRIGHT
index 09beea2..4bd9987 100644
--- a/COPYRIGHT
+++ b/COPYRIGHT
@@ -88,5 +88,5 @@ I will explicitly release it from copyright.
 The following files are trivial, in my opinion not copyrightable in
 the first place, and hereby explicitly released to the Public Domain:
 
-All public headers: include/*
+All public headers: include/*, arch/*/bits/*
 Startup files: crt/*
-- 
1.7.2.5


From 71ae0c724dd49d493621b367d17079f8cc70443c Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sat, 20 Apr 2013 14:07:01 -0400
Subject: [PATCH 05/53] comment potentially-confusing use of struct crypt_data type

---
 src/crypt/crypt.c   |    7 ++++++-
 src/crypt/crypt_r.c |    4 ++++
 2 files changed, 10 insertions(+), 1 deletions(-)

diff --git a/src/crypt/crypt.c b/src/crypt/crypt.c
index f1e310f..4650073 100644
--- a/src/crypt/crypt.c
+++ b/src/crypt/crypt.c
@@ -5,7 +5,12 @@ char *__crypt_r(const char *, const char *, struct crypt_data *);
 
 char *crypt(const char *key, const char *salt)
 {
-	/* Note: update this size when we add more hash types */
+	/* This buffer is sufficiently large for all
+	 * currently-supported hash types. It needs to be updated if
+	 * longer hashes are added. The cast to struct crypt_data * is
+	 * purely to meet the public API requirements of the crypt_r
+	 * function; the implementation of crypt_r uses the object
+	 * purely as a char buffer. */
 	static char buf[128];
 	return __crypt_r(key, salt, (struct crypt_data *)buf);
 }
diff --git a/src/crypt/crypt_r.c b/src/crypt/crypt_r.c
index 3257e8b..5982c4c 100644
--- a/src/crypt/crypt_r.c
+++ b/src/crypt/crypt_r.c
@@ -11,6 +11,10 @@ char *__crypt_sha512(const char *, const char *, char *);
 
 char *__crypt_r(const char *key, const char *salt, struct crypt_data *data)
 {
+	/* Per the crypt_r API, the caller has provided a pointer to
+	 * struct crypt_data; however, this implementation does not
+	 * use the structure to store any internal state, and treats
+	 * it purely as a char buffer for storing the result. */
 	char *output = (char *)data;
 	if (salt[0] == '$' && salt[1] && salt[2]) {
 		if (salt[1] == '1' && salt[2] == '$')
-- 
1.7.2.5


From ae0c1de530bc3b27069008b8b247171d08dbe80b Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Mon, 22 Apr 2013 10:17:56 -0400
Subject: [PATCH 06/53] fix reversed argument order x86_64 sigsetjmp's call to sigprocmask

this caused sigsetjmp not to save the signal mask but instead to
clobber it with whatever happened to be in the sigjmb_buf prior to the
call.
---
 src/signal/x86_64/sigsetjmp.s |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/signal/x86_64/sigsetjmp.s b/src/signal/x86_64/sigsetjmp.s
index 94d7148..dc38f03 100644
--- a/src/signal/x86_64/sigsetjmp.s
+++ b/src/signal/x86_64/sigsetjmp.s
@@ -6,8 +6,8 @@ sigsetjmp:
 	movq %rsi,64(%rdi)
 	jz 1f
 	pushq %rdi
-	leaq 72(%rdi),%rsi
-	xorl %edx,%edx
+	leaq 72(%rdi),%rdx
+	xorl %esi,%esi
 	movl $2,%edi
 	call sigprocmask
 	popq %rdi
-- 
1.7.2.5


From 43653c1250ad5eb5385d7e08292ad047420f8d25 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Mon, 22 Apr 2013 20:47:34 -0400
Subject: [PATCH 07/53] remove __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS checks in stdint.h

C++11, the first C++ with stdint.h, requires the previously protected
macros to be exposed unconditionally by stdint.h. apparently these
checks were an early attempt by the C committee to guess what the C++
committee would want, and they guessed wrong.
---
 include/stdint.h |    8 --------
 1 files changed, 0 insertions(+), 8 deletions(-)

diff --git a/include/stdint.h b/include/stdint.h
index 138fb21..7628404 100644
--- a/include/stdint.h
+++ b/include/stdint.h
@@ -39,8 +39,6 @@ typedef uint16_t uint_least16_t;
 typedef uint32_t uint_least32_t;
 typedef uint64_t uint_least64_t;
 
-#if !defined __cplusplus || defined __STDC_LIMIT_MACROS
-
 #define INT8_MIN   (-1-0x7f)
 #define INT16_MIN  (-1-0x7fff)
 #define INT32_MIN  (-1-0x7fffffff)
@@ -88,10 +86,6 @@ typedef uint64_t uint_least64_t;
 
 #include <bits/stdint.h>
 
-#endif
-
-#if !defined __cplusplus || defined __STDC_CONSTANT_MACROS
-
 #define INT8_C(c)  c
 #define INT16_C(c) c
 #define INT32_C(c) c
@@ -113,5 +107,3 @@ typedef uint64_t uint_least64_t;
 #endif
 
 #endif
-
-#endif
-- 
1.7.2.5


From a0473a0c826016aec1181819fcd4fff5c074f042 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 26 Apr 2013 15:09:49 -0400
Subject: [PATCH 08/53] remove explicit locking to prevent __synccall setuid during posix_spawn

for the duration of the vm-sharing clone used by posix_spawn, all
signals are blocked in the parent process, including
implementation-internal signals. since __synccall cannot do anything
until successfully signaling all threads, the fact that signals are
blocked automatically yields the necessary safety.

aside from debloating and general simplification, part of the
motivation for removing the explicit lock is to simplify the
synchronization logic of __synccall in hopes that it can be made
async-signal-safe, which is needed to make setuid and setgid, which
depend on __synccall, conform to the standard. whether this will be
possible remains to be seen.
---
 src/process/posix_spawn.c |   13 -------------
 1 files changed, 0 insertions(+), 13 deletions(-)

diff --git a/src/process/posix_spawn.c b/src/process/posix_spawn.c
index dd45012..e6a031c 100644
--- a/src/process/posix_spawn.c
+++ b/src/process/posix_spawn.c
@@ -10,12 +10,6 @@
 #include "fdop.h"
 #include "libc.h"
 
-static void dummy_0()
-{
-}
-weak_alias(dummy_0, __acquire_ptc);
-weak_alias(dummy_0, __release_ptc);
-
 struct args {
 	int p[2];
 	sigset_t oldmask;
@@ -144,10 +138,6 @@ int __posix_spawnx(pid_t *restrict res, const char *restrict path,
 	args.envp = envp;
 	pthread_sigmask(SIG_BLOCK, SIGALL_SET, &args.oldmask);
 
-	/* This lock prevents setuid/setgid operations while the parent
-	 * is sharing memory with the child. Situations where processes
-	 * with different permissions share VM are fundamentally unsafe. */
-	__acquire_ptc();
 	pid = __clone(child, stack+sizeof stack, CLONE_VM|SIGCHLD, &args);
 	close(args.p[1]);
 
@@ -158,9 +148,6 @@ int __posix_spawnx(pid_t *restrict res, const char *restrict path,
 		ec = -pid;
 	}
 
-	/* At this point, the child has either exited or successfully
-	 * performed exec, so the lock may be released. */
-	__release_ptc();
 	close(args.p[0]);
 
 	if (!ec) *res = pid;
-- 
1.7.2.5


From 23f21c304fd6a7592b70927e247129c5a2bc2390 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 26 Apr 2013 15:47:44 -0400
Subject: [PATCH 09/53] always block signals in pthread_exit before decrementing thread count

the thread count (1+libc.threads_minus_1) must always be greater than
or equal to the number of threads which could have application code
running, even in an async-signal-safe sense. there is at least one
dangerous race condition if this invariant fails to hold: dlopen could
allocate too little TLS for existing threads, and a signal handler
running in the exiting thread could claim the allocated TLS for itself
(via __tls_get_addr), leaving too little for the other threads it was
allocated for and thereby causing out-of-bounds access.

there may be other situations where it's dangerous for the thread
count to be too low, particularly in the case where only one thread
should be left, in which case locking may be omitted. however, all
such code paths seem to arise from undefined behavior, since
async-signal-unsafe functions are not permitted to be called from a
signal handler that interrupts pthread_exit (which is itself
async-signal-unsafe).

this change may also simplify logic in __synccall and improve the
chances of making __synccall async-signal-safe.
---
 src/thread/pthread_create.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index e6760ab..0cd2d6c 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -32,6 +32,8 @@ _Noreturn void pthread_exit(void *result)
 	self->dead = 1;
 	__unlock(self->killlock);
 
+	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, SIGALL_SET, 0, _NSIG/8);
+
 	do n = libc.threads_minus_1;
 	while (n && a_cas(&libc.threads_minus_1, n, n-1)!=n);
 	if (!n) exit(0);
@@ -39,8 +41,6 @@ _Noreturn void pthread_exit(void *result)
 	if (self->detached && self->map_base) {
 		if (self->detached == 2)
 			__syscall(SYS_set_tid_address, 0);
-		__syscall(SYS_rt_sigprocmask, SIG_BLOCK,
-			SIGALL_SET, 0, _NSIG/8);
 		__unmapself(self->map_base, self->map_size);
 	}
 
-- 
1.7.2.5


From 6e531f999a82cf39a951e1e9bba3cb80a6eb1464 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 26 Apr 2013 16:04:30 -0400
Subject: [PATCH 10/53] add comments on some of the pthread_exit logic

---
 src/thread/pthread_create.c |   17 +++++++++++++++--
 1 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index 0cd2d6c..6a37ee9 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -32,6 +32,10 @@ _Noreturn void pthread_exit(void *result)
 	self->dead = 1;
 	__unlock(self->killlock);
 
+	/* Block all signals before decrementing the live thread count.
+	 * This is important to ensure that dynamically allocated TLS
+	 * is not under-allocated/over-committed, and possibly for other
+	 * reasons as well. */
 	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, SIGALL_SET, 0, _NSIG/8);
 
 	do n = libc.threads_minus_1;
@@ -39,8 +43,17 @@ _Noreturn void pthread_exit(void *result)
 	if (!n) exit(0);
 
 	if (self->detached && self->map_base) {
-		if (self->detached == 2)
-			__syscall(SYS_set_tid_address, 0);
+		/* Detached threads must avoid the kernel clear_child_tid
+		 * feature, since the virtual address will have been
+		 * unmapped and possibly already reused by a new mapping
+		 * at the time the kernel would perform the write. In
+		 * the case of threads that started out detached, the
+		 * initial clone flags are correct, but if the thread was
+		 * detached later (== 2), we need to clear it here. */
+		if (self->detached == 2) __syscall(SYS_set_tid_address, 0);
+
+		/* The following call unmaps the thread's stack mapping
+		 * and then exits without touching the stack. */
 		__unmapself(self->map_base, self->map_size);
 	}
 
-- 
1.7.2.5


From c3a6839ce95c0f93bd73f7fbe5fcaee4054e5b62 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 26 Apr 2013 16:05:39 -0400
Subject: [PATCH 11/53] use atomic decrement rather than cas in pthread_exit thread count

now that blocking signals prevents any application code from running
while the last thread is exiting, the cas logic is no longer needed to
prevent decrementing below zero.
---
 src/thread/pthread_create.c |    5 +----
 1 files changed, 1 insertions(+), 4 deletions(-)

diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index 6a37ee9..0567f96 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -12,7 +12,6 @@ weak_alias(dummy_0, __pthread_tsd_run_dtors);
 _Noreturn void pthread_exit(void *result)
 {
 	pthread_t self = pthread_self();
-	int n;
 
 	self->result = result;
 
@@ -38,9 +37,7 @@ _Noreturn void pthread_exit(void *result)
 	 * reasons as well. */
 	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, SIGALL_SET, 0, _NSIG/8);
 
-	do n = libc.threads_minus_1;
-	while (n && a_cas(&libc.threads_minus_1, n, n-1)!=n);
-	if (!n) exit(0);
+	if (a_fetch_add(&libc.threads_minus_1, -1)==0) exit(0);
 
 	if (self->detached && self->map_base) {
 		/* Detached threads must avoid the kernel clear_child_tid
-- 
1.7.2.5


From d0ba09837bc033e236e921304b213daea0fe2653 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 26 Apr 2013 16:16:04 -0400
Subject: [PATCH 12/53] make last thread's pthread_exit give exit(0) a consistent state

the previous few commits ended up leaving the thread count and signal
mask wrong for atexit handlers and stdio cleanup.
---
 src/thread/pthread_create.c |   14 ++++++++++++--
 1 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index 0567f96..5d5d3a6 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -12,6 +12,7 @@ weak_alias(dummy_0, __pthread_tsd_run_dtors);
 _Noreturn void pthread_exit(void *result)
 {
 	pthread_t self = pthread_self();
+	sigset_t set;
 
 	self->result = result;
 
@@ -35,9 +36,18 @@ _Noreturn void pthread_exit(void *result)
 	 * This is important to ensure that dynamically allocated TLS
 	 * is not under-allocated/over-committed, and possibly for other
 	 * reasons as well. */
-	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, SIGALL_SET, 0, _NSIG/8);
-
-	if (a_fetch_add(&libc.threads_minus_1, -1)==0) exit(0);
+	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, SIGALL_SET, &set, _NSIG/8);
+
+	/* It's impossible to determine whether this is "the last thread"
+	 * until performing the atomic decrement, since multiple threads
+	 * could exit at the same time. For the last thread, revert the
+	 * decrement and unblock signals to give the atexit handlers and
+	 * stdio cleanup code a consistent state. */
+	if (a_fetch_add(&libc.threads_minus_1, -1)==0) {
+		libc.threads_minus_1 = 0;
+		__syscall(SYS_rt_sigprocmask, SIG_SETMASK, &set, 0, _NSIG/8);
+		exit(0);
+	}
 
 	if (self->detached && self->map_base) {
 		/* Detached threads must avoid the kernel clear_child_tid
-- 
1.7.2.5


From 082fb4e9bfd105fab3443c7b055bd9c22bdffcec Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 26 Apr 2013 17:30:32 -0400
Subject: [PATCH 13/53] fix clobbering of signal mask when creating thread with sched attributes

this was simply a case of saving the state in the wrong place.
---
 src/thread/pthread_create.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index 5d5d3a6..cf9cb19 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -197,7 +197,7 @@ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp
 	if (attr._a_sched) {
 		do_sched = new->startlock[0] = 1;
 		__syscall(SYS_rt_sigprocmask, SIG_BLOCK,
-			SIGALL_SET, self->sigmask, _NSIG/8);
+			SIGALL_SET, new->sigmask, _NSIG/8);
 	}
 	new->unblock_cancel = self->cancel;
 	new->canary = self->canary;
-- 
1.7.2.5


From 47d2bf5103fe7c65ae8dd18ba28704f143cdc9b4 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 26 Apr 2013 17:46:58 -0400
Subject: [PATCH 14/53] synccall signal handler need not handle dead threads anymore

they have already blocked signals before decrementing the thread
count, so the code being removed is unreachable in the case where the
thread is no longer counted.
---
 src/thread/synccall.c |    9 ---------
 1 files changed, 0 insertions(+), 9 deletions(-)

diff --git a/src/thread/synccall.c b/src/thread/synccall.c
index 8c825ac..706c8e7 100644
--- a/src/thread/synccall.c
+++ b/src/thread/synccall.c
@@ -21,15 +21,6 @@ static void handler(int sig, siginfo_t *si, void *ctx)
 
 	sigqueue(self->pid, SIGSYNCCALL, (union sigval){0});
 
-	/* Threads which have already decremented themselves from the
-	 * thread count must not act. Block further receipt of signals
-	 * and return. */
-	if (self->dead) {
-		memset(&((ucontext_t *)ctx)->uc_sigmask, -1, 8);
-		errno = old_errno;
-		return;
-	}
-
 	sem_init(&ch.sem, 0, 0);
 	sem_init(&ch.sem2, 0, 0);
 
-- 
1.7.2.5


From d674f8582ae8897715782ab9dfb5a039a9112a86 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 26 Apr 2013 17:51:22 -0400
Subject: [PATCH 15/53] prevent code from running under a thread id which already gave ESRCH

---
 src/thread/pthread_create.c |    8 +++++++-
 1 files changed, 7 insertions(+), 1 deletions(-)

diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index cf9cb19..6e49acd 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -30,7 +30,6 @@ _Noreturn void pthread_exit(void *result)
 	/* Mark this thread dead before decrementing count */
 	__lock(self->killlock);
 	self->dead = 1;
-	__unlock(self->killlock);
 
 	/* Block all signals before decrementing the live thread count.
 	 * This is important to ensure that dynamically allocated TLS
@@ -38,6 +37,13 @@ _Noreturn void pthread_exit(void *result)
 	 * reasons as well. */
 	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, SIGALL_SET, &set, _NSIG/8);
 
+	/* Wait to unlock the kill lock, which governs functions like
+	 * pthread_kill which target a thread id, until signals have
+	 * been blocked. This precludes observation of the thread id
+	 * as a live thread (with application code running in it) after
+	 * the thread was reported dead by ESRCH being returned. */
+	__unlock(self->killlock);
+
 	/* It's impossible to determine whether this is "the last thread"
 	 * until performing the atomic decrement, since multiple threads
 	 * could exit at the same time. For the last thread, revert the
-- 
1.7.2.5


From d53c92c972dab717f8f8e521eb0e9c4404cef4bd Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 26 Apr 2013 19:02:23 -0400
Subject: [PATCH 16/53] optimize/debloat raise

use __syscall rather than syscall when failure is not possible or not
to be considered.
---
 src/signal/raise.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/signal/raise.c b/src/signal/raise.c
index 927fe26..b24dc74 100644
--- a/src/signal/raise.c
+++ b/src/signal/raise.c
@@ -9,8 +9,8 @@ int raise(int sig)
 	int pid, tid, ret;
 	sigset_t set;
 	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, SIGALL_SET, &set, _NSIG/8);
-	tid = syscall(SYS_gettid);
-	pid = syscall(SYS_getpid);
+	tid = __syscall(SYS_gettid);
+	pid = __syscall(SYS_getpid);
 	ret = syscall(SYS_tgkill, pid, tid, sig);
 	__syscall(SYS_rt_sigprocmask, SIG_SETMASK, &set, 0, _NSIG/8);
 	return ret;
-- 
1.7.2.5


From 2c074b0d6cb2b28c5d1c0ccb2809965f4676efeb Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 26 Apr 2013 19:48:01 -0400
Subject: [PATCH 17/53] transition to using functions for internal signal blocking/restoring

there are several reasons for this change. one is getting rid of the
repetition of the syscall signature all over the place. another is
sharing the constant masks without costly GOT accesses in PIC.

the main motivation, however, is accurately representing whether we
want to block signals that might be handled by the application, or all
signals.
---
 src/internal/pthread_impl.h |    4 +++
 src/signal/block.c          |   44 +++++++++++++++++++++++++++++++++++++++++++
 src/signal/raise.c          |    4 +-
 src/signal/siglongjmp.c     |    4 +-
 src/thread/pthread_create.c |   13 ++++-------
 5 files changed, 57 insertions(+), 12 deletions(-)
 create mode 100644 src/signal/block.c

diff --git a/src/internal/pthread_impl.h b/src/internal/pthread_impl.h
index 78b69cd..67b0575 100644
--- a/src/internal/pthread_impl.h
+++ b/src/internal/pthread_impl.h
@@ -115,6 +115,10 @@ void __acquire_ptc();
 void __release_ptc();
 void __inhibit_ptc();
 
+void __block_all_sigs(void *);
+void __block_app_sigs(void *);
+void __restore_sigs(void *);
+
 #define DEFAULT_STACK_SIZE 81920
 #define DEFAULT_GUARD_SIZE PAGE_SIZE
 
diff --git a/src/signal/block.c b/src/signal/block.c
new file mode 100644
index 0000000..d7f6100
--- /dev/null
+++ b/src/signal/block.c
@@ -0,0 +1,44 @@
+#include "pthread_impl.h"
+#include "syscall.h"
+#include <signal.h>
+
+static const unsigned long all_mask[] = {
+#if ULONG_MAX == 0xffffffff && _NSIG == 129
+	-1UL, -1UL, -1UL, -1UL
+#elif ULONG_MAX == 0xffffffff
+	-1UL, -1UL
+#else
+	-1UL
+#endif
+};
+
+static const unsigned long app_mask[] = {
+#if ULONG_MAX == 0xffffffff
+#if _NSIG == 65
+	0x7fffffff, 0xfffffffc
+#else
+	0x7fffffff, 0xfffffffc, -1UL, -1UL
+#endif
+#else
+#if _NSIG == 65
+	0xfffffffc7fffffff
+#else
+	0xfffffffc7fffffff, -1UL
+#endif
+#endif
+};
+
+void __block_all_sigs(void *set)
+{
+	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, &all_mask, set, _NSIG/8);
+}
+
+void __block_app_sigs(void *set)
+{
+	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, &app_mask, set, _NSIG/8);
+}
+
+void __restore_sigs(void *set)
+{
+	__syscall(SYS_rt_sigprocmask, SIG_SETMASK, set, 0, _NSIG/8);
+}
diff --git a/src/signal/raise.c b/src/signal/raise.c
index b24dc74..6fa43be 100644
--- a/src/signal/raise.c
+++ b/src/signal/raise.c
@@ -8,10 +8,10 @@ int raise(int sig)
 {
 	int pid, tid, ret;
 	sigset_t set;
-	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, SIGALL_SET, &set, _NSIG/8);
+	__block_app_sigs(&set);
 	tid = __syscall(SYS_gettid);
 	pid = __syscall(SYS_getpid);
 	ret = syscall(SYS_tgkill, pid, tid, sig);
-	__syscall(SYS_rt_sigprocmask, SIG_SETMASK, &set, 0, _NSIG/8);
+	__restore_sigs(&set);
 	return ret;
 }
diff --git a/src/signal/siglongjmp.c b/src/signal/siglongjmp.c
index bbdde79..a7bcca2 100644
--- a/src/signal/siglongjmp.c
+++ b/src/signal/siglongjmp.c
@@ -2,10 +2,10 @@
 #include <signal.h>
 #include <stdlib.h>
 #include "syscall.h"
+#include "pthread_impl.h"
 
 _Noreturn void siglongjmp(sigjmp_buf buf, int ret)
 {
-	if (buf->__fl) __syscall(SYS_rt_sigprocmask, SIG_SETMASK,
-		buf->__ss, 0, _NSIG/8);
+	if (buf->__fl) __restore_sigs(buf->__ss);
 	longjmp(buf->__jb, ret);
 }
diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index 6e49acd..6c841be 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -35,7 +35,7 @@ _Noreturn void pthread_exit(void *result)
 	 * This is important to ensure that dynamically allocated TLS
 	 * is not under-allocated/over-committed, and possibly for other
 	 * reasons as well. */
-	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, SIGALL_SET, &set, _NSIG/8);
+	__block_all_sigs(&set);
 
 	/* Wait to unlock the kill lock, which governs functions like
 	 * pthread_kill which target a thread id, until signals have
@@ -51,7 +51,7 @@ _Noreturn void pthread_exit(void *result)
 	 * stdio cleanup code a consistent state. */
 	if (a_fetch_add(&libc.threads_minus_1, -1)==0) {
 		libc.threads_minus_1 = 0;
-		__syscall(SYS_rt_sigprocmask, SIG_SETMASK, &set, 0, _NSIG/8);
+		__restore_sigs(&set);
 		exit(0);
 	}
 
@@ -94,8 +94,7 @@ static int start(void *p)
 			self->detached = 2;
 			pthread_exit(0);
 		}
-		__syscall(SYS_rt_sigprocmask, SIG_SETMASK,
-			self->sigmask, 0, _NSIG/8);
+		__restore_sigs(self->sigmask);
 	}
 	if (self->unblock_cancel)
 		__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK,
@@ -202,8 +201,7 @@ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp
 	}
 	if (attr._a_sched) {
 		do_sched = new->startlock[0] = 1;
-		__syscall(SYS_rt_sigprocmask, SIG_BLOCK,
-			SIGALL_SET, new->sigmask, _NSIG/8);
+		__block_app_sigs(new->sigmask);
 	}
 	new->unblock_cancel = self->cancel;
 	new->canary = self->canary;
@@ -214,8 +212,7 @@ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp
 	__release_ptc();
 
 	if (do_sched) {
-		__syscall(SYS_rt_sigprocmask, SIG_SETMASK,
-			new->sigmask, 0, _NSIG/8);
+		__restore_sigs(new->sigmask);
 	}
 
 	if (ret < 0) {
-- 
1.7.2.5


From 9293b765c4449c13fe355bcfcac1934fe3426847 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sun, 5 May 2013 14:19:37 -0400
Subject: [PATCH 18/53] do not interpret errors in return value of times() syscall

all return values are valid, and on 32-bit systems, values that look
like errors can and will occur. since the only actual error this
function could return is EFAULT, and it is only returnable when the
application has invoked undefined behavior, simply ignore the
possibility that the return value is actually an error code.
---
 src/time/times.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/src/time/times.c b/src/time/times.c
index 9c50144..c4a100f 100644
--- a/src/time/times.c
+++ b/src/time/times.c
@@ -3,5 +3,5 @@
 
 clock_t times(struct tms *tms)
 {
-	return syscall(SYS_times, tms);
+	return __syscall(SYS_times, tms);
 }
-- 
1.7.2.5


From da49b872f5ef56026713855b66783c8e32570c4b Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sun, 5 May 2013 14:51:25 -0400
Subject: [PATCH 19/53] fix incorrect clock tick scaling in fallback case of clock()

since CLOCKS_PER_SEC is 1000000 (required by XSI) and the times
syscall reports values in 1/100 second units (Linux), the correct
scaling factor is 10000, not 100. note that only ancient kernels which
lack clock_gettime are affected.
---
 src/time/clock.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/src/time/clock.c b/src/time/clock.c
index d32cd09..78403af 100644
--- a/src/time/clock.c
+++ b/src/time/clock.c
@@ -11,5 +11,5 @@ clock_t clock()
 	if (!__clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts))
 		return ts.tv_sec*1000000 + ts.tv_nsec/1000;
 	__syscall(SYS_times, &tms);
-	return (tms.tms_utime + tms.tms_stime)*100;
+	return (tms.tms_utime + tms.tms_stime)*10000;
 }
-- 
1.7.2.5


From 2897bfdd602f3d6a0724bbfdd543e962926b5bbe Mon Sep 17 00:00:00 2001
From: Szabolcs Nagy <nsz@port70.net>
Date: Mon, 6 May 2013 17:52:48 +0000
Subject: [PATCH 20/53] remove compound literals from math.h to please c++

__FLOAT_BITS and __DOUBLE_BITS macros used union compound literals,
now they are changed into static inline functions. A good C compiler
generates the same code for both and the later is C++ conformant.
---
 include/math.h |   15 ++++++++++-----
 1 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/include/math.h b/include/math.h
index c4da411..0142815 100644
--- a/include/math.h
+++ b/include/math.h
@@ -43,11 +43,16 @@ int __fpclassify(double);
 int __fpclassifyf(float);
 int __fpclassifyl(long double);
 
-union __float_repr { float __f; __uint32_t __i; };
-union __double_repr { double __f; __uint64_t __i; };
-
-#define __FLOAT_BITS(f) (((union __float_repr){ (float)(f) }).__i)
-#define __DOUBLE_BITS(f) (((union __double_repr){ (double)(f) }).__i)
+static __inline __uint32_t __FLOAT_BITS(float __f)
+{
+	union {float __f; __uint32_t __i;} __u = {__f};
+	return __u.__i;
+}
+static __inline __uint64_t __DOUBLE_BITS(double __f)
+{
+	union {double __f; __uint64_t __i;} __u = {__f};
+	return __u.__i;
+}
 
 #define fpclassify(x) ( \
 	sizeof(x) == sizeof(float) ? __fpclassifyf(x) : \
-- 
1.7.2.5


From 2c184264eae3797de028403ed1e86c1f7ae5b813 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Wed, 15 May 2013 16:15:50 -0400
Subject: [PATCH 21/53] support full range of dev_t major/minor numbers in makedev, etc. macros

---
 include/sys/sysmacros.h |   13 ++++++++++---
 1 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/include/sys/sysmacros.h b/include/sys/sysmacros.h
index 2285271..d6c6aef 100644
--- a/include/sys/sysmacros.h
+++ b/include/sys/sysmacros.h
@@ -1,8 +1,15 @@
 #ifndef _SYS_SYSMACROS_H
 #define _SYS_SYSMACROS_H
 
-#define major(x) ((unsigned)((x) >> 8) & 0xff)
-#define minor(x) ((unsigned)(x) & 0xff)
-#define makedev(x,y) (((x)<<8)|((y)&0xff))
+#define major(x) \
+	((unsigned)( (((x)>>32) & 0xfffff000) | (((x)>>8) & 0x00000fff) ))
+#define minor(x) \
+	((unsigned)( (((x)>>12) & 0xffffff00) | ((x) & 0x000000ff) ))
+
+#define makedev(x,y) ( \
+        (((x)&0xfffff000ULL) << 32) | \
+	(((x)&0x00000fffULL) << 8) | \
+        (((y)&0xffffff00ULL) << 12) | \
+	(((y)&0x000000ffULL)) )
 
 #endif
-- 
1.7.2.5


From e216951f509b71da193da2fc63e25b998740d58b Mon Sep 17 00:00:00 2001
From: Szabolcs Nagy <nsz@port70.net>
Date: Wed, 15 May 2013 23:08:52 +0000
Subject: [PATCH 22/53] math: use double_t for temporaries to avoid stores on i386

When FLT_EVAL_METHOD!=0 (only i386 with x87 fp) the excess
precision of an expression must be removed in an assignment.
(gcc needs -fexcess-precision=standard or -std=c99 for this)

This is done by extra load/store instructions which adds code
bloat when lot of temporaries are used and it makes the result
less precise in many cases.
Using double_t and float_t avoids these issues on i386 and
it makes no difference on other archs.

For now only a few functions are modified where the excess
precision is clearly beneficial (mostly polynomial evaluations
with temporaries).

object size differences on i386, gcc-4.8:
             old   new
__cosdf.o    123    95
__cos.o      199   169
__sindf.o    131    95
__sin.o      225   203
__tandf.o    207   151
__tan.o      605   499
erff.o      1470  1416
erf.o       1703  1649
j0f.o       1779  1745
j0.o        2308  2274
j1f.o       1602  1568
j1.o        2286  2252
tgamma.o    1431  1424
math/*.o   64164 63635
---
 src/math/__cos.c    |    2 +-
 src/math/__cosdf.c  |    2 +-
 src/math/__log1p.h  |    2 +-
 src/math/__log1pf.h |    2 +-
 src/math/__sin.c    |    2 +-
 src/math/__sindf.c  |    2 +-
 src/math/__tan.c    |    5 +++--
 src/math/__tandf.c  |    2 +-
 src/math/acos.c     |    2 +-
 src/math/acosf.c    |    2 +-
 src/math/asin.c     |    2 +-
 src/math/asinf.c    |    2 +-
 src/math/atan.c     |    2 +-
 src/math/atanf.c    |    2 +-
 src/math/erf.c      |    5 +++--
 src/math/erff.c     |    5 +++--
 src/math/j0.c       |    4 ++--
 src/math/j0f.c      |    4 ++--
 src/math/j1.c       |    4 ++--
 src/math/j1f.c      |    4 ++--
 src/math/tgamma.c   |    2 +-
 21 files changed, 31 insertions(+), 28 deletions(-)

diff --git a/src/math/__cos.c b/src/math/__cos.c
index 8699c1d..46cefb3 100644
--- a/src/math/__cos.c
+++ b/src/math/__cos.c
@@ -60,7 +60,7 @@ C6  = -1.13596475577881948265e-11; /* 0xBDA8FAE9, 0xBE8838D4 */
 
 double __cos(double x, double y)
 {
-	double hz,z,r,w;
+	double_t hz,z,r,w;
 
 	z  = x*x;
 	w  = z*z;
diff --git a/src/math/__cosdf.c b/src/math/__cosdf.c
index a65f7f2..2124989 100644
--- a/src/math/__cosdf.c
+++ b/src/math/__cosdf.c
@@ -25,7 +25,7 @@ C3  =  0x199342e0ee5069.0p-68; /*  0.0000243904487962774090654 */
 
 float __cosdf(double x)
 {
-	double r, w, z;
+	double_t r, w, z;
 
 	/* Try to optimize for parallel evaluation as in __tandf.c. */
 	z = x*x;
diff --git a/src/math/__log1p.h b/src/math/__log1p.h
index ec2c77b..5718711 100644
--- a/src/math/__log1p.h
+++ b/src/math/__log1p.h
@@ -81,7 +81,7 @@ Lg7 = 1.479819860511658591e-01; /* 3FC2F112 DF3E5244 */
  */
 static inline double __log1p(double f)
 {
-	double hfsq,s,z,R,w,t1,t2;
+	double_t hfsq,s,z,R,w,t1,t2;
 
 	s = f/(2.0+f);
 	z = s*s;
diff --git a/src/math/__log1pf.h b/src/math/__log1pf.h
index 99492c5..f2fbef2 100644
--- a/src/math/__log1pf.h
+++ b/src/math/__log1pf.h
@@ -22,7 +22,7 @@ Lg4 = 0xf89e26.0p-26; /* 0.24279078841 */
 
 static inline float __log1pf(float f)
 {
-	float hfsq,s,z,R,w,t1,t2;
+	float_t hfsq,s,z,R,w,t1,t2;
 
 	s = f/(2.0f + f);
 	z = s*s;
diff --git a/src/math/__sin.c b/src/math/__sin.c
index 9aead04..4030949 100644
--- a/src/math/__sin.c
+++ b/src/math/__sin.c
@@ -51,7 +51,7 @@ S6  =  1.58969099521155010221e-10; /* 0x3DE5D93A, 0x5ACFD57C */
 
 double __sin(double x, double y, int iy)
 {
-	double z,r,v,w;
+	double_t z,r,v,w;
 
 	z = x*x;
 	w = z*z;
diff --git a/src/math/__sindf.c b/src/math/__sindf.c
index 83c0d7a..8fec2a3 100644
--- a/src/math/__sindf.c
+++ b/src/math/__sindf.c
@@ -25,7 +25,7 @@ S4 =  0x16cd878c3b46a7.0p-71; /*  0.0000027183114939898219064 */
 
 float __sindf(double x)
 {
-	double r, s, w, z;
+	double_t r, s, w, z;
 
 	/* Try to optimize for parallel evaluation as in __tandf.c. */
 	z = x*x;
diff --git a/src/math/__tan.c b/src/math/__tan.c
index 01e3fe4..fc739f9 100644
--- a/src/math/__tan.c
+++ b/src/math/__tan.c
@@ -65,7 +65,7 @@ pio4lo =     3.06161699786838301793e-17; /* 3C81A626, 33145C07 */
 
 double __tan(double x, double y, int iy)
 {
-	double z, r, v, w, s, sign;
+	double_t z, r, v, w, s, sign;
 	int32_t ix, hx;
 
 	GET_HIGH_WORD(hx,x);
@@ -106,7 +106,8 @@ double __tan(double x, double y, int iy)
 		 * -1.0 / (x+r) here
 		 */
 		/* compute -1.0 / (x+r) accurately */
-		double a, t;
+		double_t a;
+		double z, t;
 		z = w;
 		SET_LOW_WORD(z,0);
 		v = r - (z - x);        /* z+v = r+x */
diff --git a/src/math/__tandf.c b/src/math/__tandf.c
index 36a8214..3e632fd 100644
--- a/src/math/__tandf.c
+++ b/src/math/__tandf.c
@@ -27,7 +27,7 @@ static const double T[] = {
 
 float __tandf(double x, int iy)
 {
-	double z,r,w,s,t,u;
+	double_t z,r,w,s,t,u;
 
 	z = x*x;
 	/*
diff --git a/src/math/acos.c b/src/math/acos.c
index cd5d06a..ea9c87b 100644
--- a/src/math/acos.c
+++ b/src/math/acos.c
@@ -51,7 +51,7 @@ qS4 =  7.70381505559019352791e-02; /* 0x3FB3B8C5, 0xB12E9282 */
 
 static double R(double z)
 {
-	double p, q;
+	double_t p, q;
 	p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
 	q = 1.0+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
 	return p/q;
diff --git a/src/math/acosf.c b/src/math/acosf.c
index 5d7c027..8ee1a71 100644
--- a/src/math/acosf.c
+++ b/src/math/acosf.c
@@ -25,7 +25,7 @@ qS1 = -7.0662963390e-01;
 
 static float R(float z)
 {
-	float p, q;
+	float_t p, q;
 	p = z*(pS0+z*(pS1+z*pS2));
 	q = 1.0f+z*qS1;
 	return p/q;
diff --git a/src/math/asin.c b/src/math/asin.c
index d61c04b..3e8f99e 100644
--- a/src/math/asin.c
+++ b/src/math/asin.c
@@ -58,7 +58,7 @@ qS4 =  7.70381505559019352791e-02; /* 0x3FB3B8C5, 0xB12E9282 */
 
 static double R(double z)
 {
-	double p, q;
+	double_t p, q;
 	p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
 	q = 1.0+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
 	return p/q;
diff --git a/src/math/asinf.c b/src/math/asinf.c
index 462bf04..51fe6c6 100644
--- a/src/math/asinf.c
+++ b/src/math/asinf.c
@@ -26,7 +26,7 @@ qS1 = -7.0662963390e-01;
 
 static float R(float z)
 {
-	float p, q;
+	float_t p, q;
 	p = z*(pS0+z*(pS1+z*pS2));
 	q = 1.0f+z*qS1;
 	return p/q;
diff --git a/src/math/atan.c b/src/math/atan.c
index 3c9a59f..5a1d33e 100644
--- a/src/math/atan.c
+++ b/src/math/atan.c
@@ -62,7 +62,7 @@ static const double aT[] = {
 
 double atan(double x)
 {
-	double w,s1,s2,z;
+	double_t w,s1,s2,z;
 	uint32_t ix,sign;
 	int id;
 
diff --git a/src/math/atanf.c b/src/math/atanf.c
index 4b59509..ac8bfd0 100644
--- a/src/math/atanf.c
+++ b/src/math/atanf.c
@@ -40,7 +40,7 @@ static const float aT[] = {
 
 float atanf(float x)
 {
-	float w,s1,s2,z;
+	float_t w,s1,s2,z;
 	uint32_t ix,sign;
 	int id;
 
diff --git a/src/math/erf.c b/src/math/erf.c
index c0fc41d..2f30a29 100644
--- a/src/math/erf.c
+++ b/src/math/erf.c
@@ -176,7 +176,7 @@ sb7  = -2.24409524465858183362e+01; /* 0xC03670E2, 0x42712D62 */
 
 static double erfc1(double x)
 {
-	double s,P,Q;
+	double_t s,P,Q;
 
 	s = fabs(x) - 1;
 	P = pa0+s*(pa1+s*(pa2+s*(pa3+s*(pa4+s*(pa5+s*pa6)))));
@@ -186,7 +186,8 @@ static double erfc1(double x)
 
 static double erfc2(uint32_t ix, double x)
 {
-	double s,z,R,S;
+	double_t s,R,S;
+	double z;
 
 	if (ix < 0x3ff40000)  /* |x| < 1.25 */
 		return erfc1(x);
diff --git a/src/math/erff.c b/src/math/erff.c
index e2cfc98..ed5f397 100644
--- a/src/math/erff.c
+++ b/src/math/erff.c
@@ -86,7 +86,7 @@ sb7  = -2.2440952301e+01; /* 0xc1b38712 */
 
 static float erfc1(float x)
 {
-	float s,P,Q;
+	float_t s,P,Q;
 
 	s = fabsf(x) - 1;
 	P = pa0+s*(pa1+s*(pa2+s*(pa3+s*(pa4+s*(pa5+s*pa6)))));
@@ -96,7 +96,8 @@ static float erfc1(float x)
 
 static float erfc2(uint32_t ix, float x)
 {
-	float s,z,R,S;
+	float_t s,R,S;
+	float z;
 
 	if (ix < 0x3fa00000)  /* |x| < 1.25 */
 		return erfc1(x);
diff --git a/src/math/j0.c b/src/math/j0.c
index b281e13..d722d94 100644
--- a/src/math/j0.c
+++ b/src/math/j0.c
@@ -263,7 +263,7 @@ static const double pS2[5] = {
 static double pzero(double x)
 {
 	const double *p,*q;
-	double z,r,s;
+	double_t z,r,s;
 	uint32_t ix;
 
 	GET_HIGH_WORD(ix, x);
@@ -359,7 +359,7 @@ static const double qS2[6] = {
 static double qzero(double x)
 {
 	const double *p,*q;
-	double s,r,z;
+	double_t s,r,z;
 	uint32_t ix;
 
 	GET_HIGH_WORD(ix, x);
diff --git a/src/math/j0f.c b/src/math/j0f.c
index 79bab62..4b0ee3b 100644
--- a/src/math/j0f.c
+++ b/src/math/j0f.c
@@ -201,7 +201,7 @@ static const float pS2[5] = {
 static float pzerof(float x)
 {
 	const float *p,*q;
-	float z,r,s;
+	float_t z,r,s;
 	uint32_t ix;
 
 	GET_FLOAT_WORD(ix, x);
@@ -297,7 +297,7 @@ static const float qS2[6] = {
 static float qzerof(float x)
 {
 	const float *p,*q;
-	float s,r,z;
+	float_t s,r,z;
 	uint32_t ix;
 
 	GET_FLOAT_WORD(ix, x);
diff --git a/src/math/j1.c b/src/math/j1.c
index ac7bb1e..df724d1 100644
--- a/src/math/j1.c
+++ b/src/math/j1.c
@@ -250,7 +250,7 @@ static const double ps2[5] = {
 static double pone(double x)
 {
 	const double *p,*q;
-	double z,r,s;
+	double_t z,r,s;
 	uint32_t ix;
 
 	GET_HIGH_WORD(ix, x);
@@ -346,7 +346,7 @@ static const double qs2[6] = {
 static double qone(double x)
 {
 	const double *p,*q;
-	double  s,r,z;
+	double_t s,r,z;
 	uint32_t ix;
 
 	GET_HIGH_WORD(ix, x);
diff --git a/src/math/j1f.c b/src/math/j1f.c
index 5a760f7..6abde34 100644
--- a/src/math/j1f.c
+++ b/src/math/j1f.c
@@ -198,7 +198,7 @@ static const float ps2[5] = {
 static float ponef(float x)
 {
 	const float *p,*q;
-	float z,r,s;
+	float_t z,r,s;
 	uint32_t ix;
 
 	GET_FLOAT_WORD(ix, x);
@@ -294,7 +294,7 @@ static const float qs2[6] = {
 static float qonef(float x)
 {
 	const float *p,*q;
-	float s,r,z;
+	float_t s,r,z;
 	uint32_t ix;
 
 	GET_FLOAT_WORD(ix, x);
diff --git a/src/math/tgamma.c b/src/math/tgamma.c
index a3f203c..691e86a 100644
--- a/src/math/tgamma.c
+++ b/src/math/tgamma.c
@@ -89,7 +89,7 @@ static const double fact[] = {
 /* S(x) rational function for positive x */
 static double S(double x)
 {
-	double num = 0, den = 0;
+	double_t num = 0, den = 0;
 	int i;
 
 	/* to avoid overflow handle large x differently */
-- 
1.7.2.5


From 1a70198b3e5a7866bf4c62d090d8a8e28b12521a Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Thu, 16 May 2013 16:27:37 -0400
Subject: [PATCH 23/53] fix mknod and mknodat to accept large dev_t values

support for these was recently added to sysmacros.h. note that the
syscall argument is a long, despite dev_t being 64-bit, so on 32-bit
archs the high bits will be lost. it appears the high bits are just
glibc silliness and not part of the kernel api, anyway, but it's nice
that we have them there for future expansion if needed.
---
 src/stat/mknod.c   |    5 +----
 src/stat/mknodat.c |    2 +-
 2 files changed, 2 insertions(+), 5 deletions(-)

diff --git a/src/stat/mknod.c b/src/stat/mknod.c
index 90c6a1c..c319657 100644
--- a/src/stat/mknod.c
+++ b/src/stat/mknod.c
@@ -3,8 +3,5 @@
 
 int mknod(const char *path, mode_t mode, dev_t dev)
 {
-	/* since dev_t is system-specific anyway we defer to the idiotic
-	 * legacy-compatible bitfield mapping of the type.. at least we've
-	 * made it large enough to leave space for future expansion.. */
-	return syscall(SYS_mknod, path, mode, dev & 0xffff);
+	return syscall(SYS_mknod, path, mode, dev);
 }
diff --git a/src/stat/mknodat.c b/src/stat/mknodat.c
index 63cacd5..7c97c91 100644
--- a/src/stat/mknodat.c
+++ b/src/stat/mknodat.c
@@ -3,5 +3,5 @@
 
 int mknodat(int fd, const char *path, mode_t mode, dev_t dev)
 {
-	return syscall(SYS_mknodat, fd, path, mode, dev & 0xffff);
+	return syscall(SYS_mknodat, fd, path, mode, dev);
 }
-- 
1.7.2.5


From ec9f5353b10eb312af391ec799a3eeea5da145a9 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 17 May 2013 14:23:41 -0400
Subject: [PATCH 24/53] remove the __STDC_FORMAT_MACROS nonsense from inttypes.h

somehow I missed this when removing the corresponding
__STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS nonsense from stdint.h.
these were all attempts by the C committee to guess what the C++
committee would want, and the guesses turned out to be wrong.
---
 include/inttypes.h |    4 ----
 1 files changed, 0 insertions(+), 4 deletions(-)

diff --git a/include/inttypes.h b/include/inttypes.h
index 05d54ba..c51769f 100644
--- a/include/inttypes.h
+++ b/include/inttypes.h
@@ -22,8 +22,6 @@ uintmax_t strtoumax(const char *__restrict, char **__restrict, int);
 intmax_t wcstoimax(const wchar_t *__restrict, wchar_t **__restrict, int);
 uintmax_t wcstoumax(const wchar_t *__restrict, wchar_t **__restrict, int);
 
-#if !defined __cplusplus || defined __STDC_FORMAT_MACROS
-
 #if UINTPTR_MAX == UINT64_MAX
 #define __PRI64  "l"
 #else
@@ -221,8 +219,6 @@ uintmax_t wcstoumax(const wchar_t *__restrict, wchar_t **__restrict, int);
 #define SCNuPTR "lu"
 #define SCNxPTR "lx"
 
-#endif
-
 #ifdef __cplusplus
 }
 #endif
-- 
1.7.2.5


From 22730d65608db06500cc6e0be4aaec03238f996b Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 17 May 2013 18:38:42 -0400
Subject: [PATCH 25/53] add FLT_TRUE_MIN, etc. macros from C11

there was some question as to how many decimal places to use, since
one decimal place is always sufficient to identify the smallest
denormal uniquely. for now, I'm following the example in the C
standard which is consistent with the other min/max macros we already
had in place.
---
 arch/arm/bits/float.h        |    1 +
 arch/i386/bits/float.h       |    1 +
 arch/microblaze/bits/float.h |    1 +
 arch/mips/bits/float.h       |    1 +
 arch/powerpc/bits/float.h    |    1 +
 arch/x86_64/bits/float.h     |    1 +
 include/float.h              |    2 ++
 7 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/arch/arm/bits/float.h b/arch/arm/bits/float.h
index dce9e2d..89e9eb6 100644
--- a/arch/arm/bits/float.h
+++ b/arch/arm/bits/float.h
@@ -1,6 +1,7 @@
 #define FLT_ROUNDS 1
 #define FLT_EVAL_METHOD 0
 
+#define LDBL_TRUE_MIN 4.9406564584124654e-324
 #define LDBL_MIN 2.2250738585072014e-308
 #define LDBL_MAX 1.7976931348623157e+308
 #define LDBL_EPSILON 2.2204460492503131e-16
diff --git a/arch/i386/bits/float.h b/arch/i386/bits/float.h
index e18267d..c356cba 100644
--- a/arch/i386/bits/float.h
+++ b/arch/i386/bits/float.h
@@ -5,6 +5,7 @@
 #define FLT_EVAL_METHOD 2
 #endif
 
+#define LDBL_TRUE_MIN 3.6451995318824746025e-4951L
 #define LDBL_MIN     3.3621031431120935063e-4932L
 #define LDBL_MAX     1.1897314953572317650e+4932L
 #define LDBL_EPSILON 1.0842021724855044340e-19L
diff --git a/arch/microblaze/bits/float.h b/arch/microblaze/bits/float.h
index dce9e2d..89e9eb6 100644
--- a/arch/microblaze/bits/float.h
+++ b/arch/microblaze/bits/float.h
@@ -1,6 +1,7 @@
 #define FLT_ROUNDS 1
 #define FLT_EVAL_METHOD 0
 
+#define LDBL_TRUE_MIN 4.9406564584124654e-324
 #define LDBL_MIN 2.2250738585072014e-308
 #define LDBL_MAX 1.7976931348623157e+308
 #define LDBL_EPSILON 2.2204460492503131e-16
diff --git a/arch/mips/bits/float.h b/arch/mips/bits/float.h
index dce9e2d..89e9eb6 100644
--- a/arch/mips/bits/float.h
+++ b/arch/mips/bits/float.h
@@ -1,6 +1,7 @@
 #define FLT_ROUNDS 1
 #define FLT_EVAL_METHOD 0
 
+#define LDBL_TRUE_MIN 4.9406564584124654e-324
 #define LDBL_MIN 2.2250738585072014e-308
 #define LDBL_MAX 1.7976931348623157e+308
 #define LDBL_EPSILON 2.2204460492503131e-16
diff --git a/arch/powerpc/bits/float.h b/arch/powerpc/bits/float.h
index dce9e2d..89e9eb6 100644
--- a/arch/powerpc/bits/float.h
+++ b/arch/powerpc/bits/float.h
@@ -1,6 +1,7 @@
 #define FLT_ROUNDS 1
 #define FLT_EVAL_METHOD 0
 
+#define LDBL_TRUE_MIN 4.9406564584124654e-324
 #define LDBL_MIN 2.2250738585072014e-308
 #define LDBL_MAX 1.7976931348623157e+308
 #define LDBL_EPSILON 2.2204460492503131e-16
diff --git a/arch/x86_64/bits/float.h b/arch/x86_64/bits/float.h
index 17fd74d..9ea2991 100644
--- a/arch/x86_64/bits/float.h
+++ b/arch/x86_64/bits/float.h
@@ -5,6 +5,7 @@
 #define FLT_EVAL_METHOD 0
 #endif
 
+#define LDBL_TRUE_MIN 3.6451995318824746025e-4951L
 #define LDBL_MIN     3.3621031431120935063e-4932L
 #define LDBL_MAX     1.1897314953572317650e+4932L
 #define LDBL_EPSILON 1.0842021724855044340e-19L
diff --git a/include/float.h b/include/float.h
index ea25f27..c7b208a 100644
--- a/include/float.h
+++ b/include/float.h
@@ -3,6 +3,7 @@
 
 #define FLT_RADIX 2
 
+#define FLT_TRUE_MIN 1.40129846e-45F
 #define FLT_MIN 1.17549435e-38F
 #define FLT_MAX 3.40282347e+38F
 #define FLT_EPSILON 1.19209290e-07F
@@ -15,6 +16,7 @@
 #define FLT_MIN_10_EXP (-37)
 #define FLT_MAX_10_EXP 38
 
+#define DBL_TRUE_MIN 4.9406564584124654e-324
 #define DBL_MIN 2.2250738585072014e-308
 #define DBL_MAX 1.7976931348623157e+308
 #define DBL_EPSILON 2.2204460492503131e-16
-- 
1.7.2.5


From 1d5ba3bb5a3f55e10db05219638cfcd967d65417 Mon Sep 17 00:00:00 2001
From: Szabolcs Nagy <nsz@port70.net>
Date: Sat, 18 May 2013 12:34:00 +0000
Subject: [PATCH 26/53] math: tan cleanups

* use unsigned arithmetics on the representation
* store arg reduction quotient in unsigned (so n%2 would work like n&1)
* use different convention to pass the arg reduction bit to __tan
  (this argument used to be 1 for even and -1 for odd reduction
  which meant obscure bithacks, the new n&1 is cleaner)
* raise inexact and underflow flags correctly for small x
  (tanl(x) may still raise spurious underflow for small but normal x)
  (this exception raising code increases codesize a bit, similar fixes
  are needed in many other places, it may worth investigating at some
  point if the inexact and underflow flags are worth raising correctly
  as this is not strictly required by the standard)
* tanf manual reduction optimization is kept for now
* tanl code path is cleaned up to follow similar logic to tan and tanf
---
 src/math/__tan.c   |   57 +++++++++++++++++++++------------------------------
 src/math/__tandf.c |    5 +--
 src/math/__tanl.c  |   32 ++++++++++++----------------
 src/math/tan.c     |   23 +++++++++++----------
 src/math/tanf.c    |   32 +++++++++++++++-------------
 src/math/tanl.c    |   37 ++++++++++-----------------------
 6 files changed, 80 insertions(+), 106 deletions(-)

diff --git a/src/math/__tan.c b/src/math/__tan.c
index fc739f9..8019844 100644
--- a/src/math/__tan.c
+++ b/src/math/__tan.c
@@ -12,7 +12,7 @@
  * kernel tan function on ~[-pi/4, pi/4] (except on -0), pi/4 ~ 0.7854
  * Input x is assumed to be bounded by ~pi/4 in magnitude.
  * Input y is the tail of x.
- * Input k indicates whether tan (if k = 1) or -1/tan (if k = -1) is returned.
+ * Input odd indicates whether tan (if odd = 0) or -1/tan (if odd = 1) is returned.
  *
  * Algorithm
  *      1. Since tan(-x) = -tan(x), we need only to consider positive x.
@@ -63,21 +63,22 @@ static const double T[] = {
 pio4 =       7.85398163397448278999e-01, /* 3FE921FB, 54442D18 */
 pio4lo =     3.06161699786838301793e-17; /* 3C81A626, 33145C07 */
 
-double __tan(double x, double y, int iy)
+double __tan(double x, double y, int odd)
 {
-	double_t z, r, v, w, s, sign;
-	int32_t ix, hx;
+	double_t z, r, v, w, s, a;
+	double w0, a0;
+	uint32_t hx;
+	int big, sign;
 
 	GET_HIGH_WORD(hx,x);
-	ix = hx & 0x7fffffff;    /* high word of |x| */
-	if (ix >= 0x3FE59428) {  /* |x| >= 0.6744 */
-		if (hx < 0) {
+	big = (hx&0x7fffffff) >= 0x3FE59428; /* |x| >= 0.6744 */
+	if (big) {
+		sign = hx>>31;
+		if (sign) {
 			x = -x;
 			y = -y;
 		}
-		z = pio4 - x;
-		w = pio4lo - y;
-		x = z + w;
+		x = (pio4 - x) + (pio4lo - y);
 		y = 0.0;
 	}
 	z = x * x;
@@ -90,30 +91,20 @@ double __tan(double x, double y, int iy)
 	r = T[1] + w*(T[3] + w*(T[5] + w*(T[7] + w*(T[9] + w*T[11]))));
 	v = z*(T[2] + w*(T[4] + w*(T[6] + w*(T[8] + w*(T[10] + w*T[12])))));
 	s = z * x;
-	r = y + z * (s * (r + v) + y);
-	r += T[0] * s;
+	r = y + z*(s*(r + v) + y) + s*T[0];
 	w = x + r;
-	if (ix >= 0x3FE59428) {
-		v = iy;
-		sign = 1 - ((hx >> 30) & 2);
-		return sign * (v - 2.0 * (x - (w * w / (w + v) - r)));
+	if (big) {
+		s = 1 - 2*odd;
+		v = s - 2.0 * (x + (r - w*w/(w + s)));
+		return sign ? -v : v;
 	}
-	if (iy == 1)
+	if (!odd)
 		return w;
-	else {
-		/*
-		 * if allow error up to 2 ulp, simply return
-		 * -1.0 / (x+r) here
-		 */
-		/* compute -1.0 / (x+r) accurately */
-		double_t a;
-		double z, t;
-		z = w;
-		SET_LOW_WORD(z,0);
-		v = r - (z - x);        /* z+v = r+x */
-		t = a = -1.0 / w;       /* a = -1.0/w */
-		SET_LOW_WORD(t,0);
-		s = 1.0 + t * z;
-		return t + a * (s + t * v);
-	}
+	/* -1.0/(x+r) has up to 2ulp error, so compute it accurately */
+	w0 = w;
+	SET_LOW_WORD(w0, 0);
+	v = r - (w0 - x);       /* w0+v = r+x */
+	a0 = a = -1.0 / w;
+	SET_LOW_WORD(a0, 0);
+	return a0 + a*(1.0 + a0*w0 + a0*v);
 }
diff --git a/src/math/__tandf.c b/src/math/__tandf.c
index 3e632fd..25047ee 100644
--- a/src/math/__tandf.c
+++ b/src/math/__tandf.c
@@ -25,7 +25,7 @@ static const double T[] = {
   0x1362b9bf971bcd.0p-59, /* 0.00946564784943673166728 */
 };
 
-float __tandf(double x, int iy)
+float __tandf(double x, int odd)
 {
 	double_t z,r,w,s,t,u;
 
@@ -50,6 +50,5 @@ float __tandf(double x, int iy)
 	s = z*x;
 	u = T[0] + z*T[1];
 	r = (x + s*u) + (s*w)*(t + w*r);
-	if(iy==1) return r;
-	else return -1.0/r;
+	return odd ? -1.0/r : r;
 }
diff --git a/src/math/__tanl.c b/src/math/__tanl.c
index 50ba214..4b36e61 100644
--- a/src/math/__tanl.c
+++ b/src/math/__tanl.c
@@ -45,25 +45,21 @@ T29 =  0.0000078293456938132840,        /*  0x106b59141a6cb3.0p-69 */
 T31 = -0.0000032609076735050182,        /* -0x1b5abef3ba4b59.0p-71 */
 T33 =  0.0000023261313142559411;        /*  0x13835436c0c87f.0p-71 */
 
-long double __tanl(long double x, long double y, int iy) {
+long double __tanl(long double x, long double y, int odd) {
 	long double z, r, v, w, s, a, t;
-	long double osign;
-	int i;
+	int big, sign;
 
-	iy = iy == 1 ? -1 : 1;        /* XXX recover original interface */
-	osign = copysignl(1.0, x);
-	if (fabsl(x) >= 0.67434) {
+	big = fabsl(x) >= 0.67434;
+	if (big) {
+		sign = 0;
 		if (x < 0) {
+			sign = 1;
 			x = -x;
 			y = -y;
 		}
-		z = pio4 - x;
-		w = pio4lo - y;
-		x = z + w;
+		x = (pio4 - x) + (pio4lo - y);
 		y = 0.0;
-		i = 1;
-	} else
-		i = 0;
+	}
 	z = x * x;
 	w = z * z;
 	r = T5 + w * (T9 + w * (T13 + w * (T17 + w * (T21 +
@@ -71,14 +67,14 @@ long double __tanl(long double x, long double y, int iy) {
 	v = z * (T7 + w * (T11 + w * (T15 + w * (T19 + w * (T23 +
 	     w * (T27 + w * T31))))));
 	s = z * x;
-	r = y + z * (s * (r + v) + y);
-	r += T3 * s;
+	r = y + z * (s * (r + v) + y) + T3 * s;
 	w = x + r;
-	if (i == 1) {
-		v = (long double)iy;
-		return osign * (v - 2.0 * (x - (w * w / (w + v) - r)));
+	if (big) {
+		s = 1 - 2*odd;
+		v = s - 2.0 * (x + (r - w * w / (w + s)));
+		return sign ? -v : v;
 	}
-	if (iy == 1)
+	if (!odd)
 		return w;
 
 	/*
diff --git a/src/math/tan.c b/src/math/tan.c
index 2e1f3c8..9c724a4 100644
--- a/src/math/tan.c
+++ b/src/math/tan.c
@@ -43,27 +43,28 @@
 
 double tan(double x)
 {
-	double y[2], z = 0.0;
-	int32_t n, ix;
+	double y[2];
+	uint32_t ix;
+	unsigned n;
 
-	/* High word of x. */
 	GET_HIGH_WORD(ix, x);
+	ix &= 0x7fffffff;
 
 	/* |x| ~< pi/4 */
-	ix &= 0x7fffffff;
 	if (ix <= 0x3fe921fb) {
-		if (ix < 0x3e400000) /* x < 2**-27 */
-			/* raise inexact if x != 0 */
-			if ((int)x == 0)
-				return x;
-		return __tan(x, z, 1);
+		if (ix < 0x3e400000) { /* |x| < 2**-27 */
+			/* raise inexact if x!=0 and underflow if subnormal */
+			FORCE_EVAL(ix < 0x00100000 ? x/0x1p120f : x+0x1p120f);
+			return x;
+		}
+		return __tan(x, 0.0, 0);
 	}
 
 	/* tan(Inf or NaN) is NaN */
 	if (ix >= 0x7ff00000)
 		return x - x;
 
-	/* argument reduction needed */
+	/* argument reduction */
 	n = __rem_pio2(x, y);
-	return __tan(y[0], y[1], 1 - ((n&1)<<1)); /* n even: 1, n odd: -1 */
+	return __tan(y[0], y[1], n&1);
 }
diff --git a/src/math/tanf.c b/src/math/tanf.c
index 8b0dfb2..aba1977 100644
--- a/src/math/tanf.c
+++ b/src/math/tanf.c
@@ -26,37 +26,39 @@ t4pio2 = 4*M_PI_2; /* 0x401921FB, 0x54442D18 */
 float tanf(float x)
 {
 	double y;
-	int32_t n, hx, ix;
+	uint32_t ix;
+	unsigned n, sign;
 
-	GET_FLOAT_WORD(hx, x);
-	ix = hx & 0x7fffffff;
+	GET_FLOAT_WORD(ix, x);
+	sign = ix >> 31;
+	ix &= 0x7fffffff;
 
 	if (ix <= 0x3f490fda) {  /* |x| ~<= pi/4 */
-		if (ix < 0x39800000)  /* |x| < 2**-12 */
-			/* return x and raise inexact if x != 0 */
-			if ((int)x == 0)
-				return x;
-		return __tandf(x, 1);
+		if (ix < 0x39800000) {  /* |x| < 2**-12 */
+			/* raise inexact if x!=0 and underflow if subnormal */
+			FORCE_EVAL(ix < 0x00800000 ? x/0x1p120f : x+0x1p120f);
+			return x;
+		}
+		return __tandf(x, 0);
 	}
 	if (ix <= 0x407b53d1) {  /* |x| ~<= 5*pi/4 */
 		if (ix <= 0x4016cbe3)  /* |x| ~<= 3pi/4 */
-			return __tandf((hx > 0 ? x-t1pio2 : x+t1pio2), -1);
+			return __tandf((sign ? x+t1pio2 : x-t1pio2), 1);
 		else
-			return __tandf((hx > 0 ? x-t2pio2 : x+t2pio2), 1);
+			return __tandf((sign ? x+t2pio2 : x-t2pio2), 0);
 	}
 	if (ix <= 0x40e231d5) {  /* |x| ~<= 9*pi/4 */
 		if (ix <= 0x40afeddf)  /* |x| ~<= 7*pi/4 */
-			return __tandf((hx > 0 ? x-t3pio2 : x+t3pio2), -1);
+			return __tandf((sign ? x+t3pio2 : x-t3pio2), 1);
 		else
-			return __tandf((hx > 0 ? x-t4pio2 : x+t4pio2), 1);
+			return __tandf((sign ? x+t4pio2 : x-t4pio2), 0);
 	}
 
 	/* tan(Inf or NaN) is NaN */
 	if (ix >= 0x7f800000)
 		return x - x;
 
-	/* general argument reduction needed */
+	/* argument reduction */
 	n = __rem_pio2f(x, &y);
-	/* integer parameter: n even: 1; n odd: -1 */
-	return __tandf(y, 1-((n&1)<<1));
+	return __tandf(y, n&1);
 }
diff --git a/src/math/tanl.c b/src/math/tanl.c
index 0194eaf..3b51e01 100644
--- a/src/math/tanl.c
+++ b/src/math/tanl.c
@@ -41,42 +41,27 @@ long double tanl(long double x)
 long double tanl(long double x)
 {
 	union IEEEl2bits z;
-	int e0, s;
 	long double y[2];
-	long double hi, lo;
+	unsigned n;
 
 	z.e = x;
-	s = z.bits.sign;
 	z.bits.sign = 0;
 
-	/* If x = +-0 or x is subnormal, then tan(x) = x. */
-	if (z.bits.exp == 0)
-		return x;
-
 	/* If x = NaN or Inf, then tan(x) = NaN. */
-	if (z.bits.exp == 32767)
+	if (z.bits.exp == 0x7fff)
 		return (x - x) / (x - x);
 
-	/* Optimize the case where x is already within range. */
+	/* |x| < (double)pi/4 */
 	if (z.e < M_PI_4) {
-		hi = __tanl(z.e, 0, 0);
-		return s ? -hi : hi;
+		/* x = +-0 or x is subnormal */
+		if (z.bits.exp == 0)
+			/* inexact and underflow if x!=0 */
+			return x + x*0x1p-120f;
+		/* can raise spurious underflow */
+		return __tanl(x, 0, 0);
 	}
 
-	e0 = __rem_pio2l(x, y);
-	hi = y[0];
-	lo = y[1];
-
-	switch (e0 & 3) {
-	case 0:
-	case 2:
-		hi = __tanl(hi, lo, 0);
-		break;
-	case 1:
-	case 3:
-		hi = __tanl(hi, lo, 1);
-		break;
-	}
-	return hi;
+	n = __rem_pio2l(x, y);
+	return __tanl(y[0], y[1], n&1);
 }
 #endif
-- 
1.7.2.5


From 69ee9b2cb169ee843ac9e209f919d088499152f7 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sat, 18 May 2013 10:20:42 -0400
Subject: [PATCH 27/53] make err.h functions print __progname

patch by Strake. previously is was not feasible to duplicate this
functionality of the functions these were modeled on, since argv[0]
was not saved at program startup, but now that it's available it's
easy to use.
---
 src/legacy/err.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/src/legacy/err.c b/src/legacy/err.c
index 0f74853..7b167b3 100644
--- a/src/legacy/err.c
+++ b/src/legacy/err.c
@@ -3,14 +3,18 @@
 #include <stdarg.h>
 #include <stdlib.h>
 
+extern char *__progname;
+
 void vwarn(const char *fmt, va_list ap)
 {
+	fprintf (stderr, "%s: ", __progname);
 	if (fmt) vfprintf(stderr, fmt, ap);
 	perror("");
 }
 
 void vwarnx(const char *fmt, va_list ap)
 {
+	fprintf (stderr, "%s: ", __progname);
 	if (fmt) vfprintf(stderr, fmt, ap);
 	putc('\n', stderr);
 }
-- 
1.7.2.5


From bfda37935867f9bf271d6074db0accf05c63ad10 Mon Sep 17 00:00:00 2001
From: Szabolcs Nagy <nsz@port70.net>
Date: Sat, 18 May 2013 14:40:22 +0000
Subject: [PATCH 28/53] math: sin cos cleanup

* use unsigned arithmetics
* use unsigned to store arg reduction quotient (so n&3 is understood)
* remove z=0.0 variables, use literal 0
* raise underflow and inexact exceptions properly when x is small
* fix spurious underflow in tanl
---
 src/math/cos.c     |   20 +++++++++++---------
 src/math/cosf.c    |   33 +++++++++++++++++++--------------
 src/math/cosl.c    |   22 +++++++++++-----------
 src/math/sin.c     |   15 ++++++++-------
 src/math/sincos.c  |   12 ++++++------
 src/math/sincosf.c |   45 ++++++++++++++++++++++++---------------------
 src/math/sincosl.c |   20 +++++++++++---------
 src/math/sinf.c    |   33 ++++++++++++++++++---------------
 src/math/sinl.c    |   29 ++++++++++++++---------------
 src/math/tanl.c    |   11 ++++++-----
 10 files changed, 128 insertions(+), 112 deletions(-)

diff --git a/src/math/cos.c b/src/math/cos.c
index 76990e7..ee97f68 100644
--- a/src/math/cos.c
+++ b/src/math/cos.c
@@ -44,26 +44,28 @@
 
 double cos(double x)
 {
-	double y[2],z=0.0;
-	int32_t n, ix;
+	double y[2];
+	uint32_t ix;
+	unsigned n;
 
 	GET_HIGH_WORD(ix, x);
+	ix &= 0x7fffffff;
 
 	/* |x| ~< pi/4 */
-	ix &= 0x7fffffff;
 	if (ix <= 0x3fe921fb) {
-		if (ix < 0x3e46a09e)  /* if x < 2**-27 * sqrt(2) */
-			/* raise inexact if x != 0 */
-			if ((int)x == 0)
-				return 1.0;
-		return __cos(x, z);
+		if (ix < 0x3e46a09e) {  /* |x| < 2**-27 * sqrt(2) */
+			/* raise inexact if x!=0 */
+			FORCE_EVAL(x + 0x1p120f);
+			return 1.0;
+		}
+		return __cos(x, 0);
 	}
 
 	/* cos(Inf or NaN) is NaN */
 	if (ix >= 0x7ff00000)
 		return x-x;
 
-	/* argument reduction needed */
+	/* argument reduction */
 	n = __rem_pio2(x, y);
 	switch (n&3) {
 	case 0: return  __cos(y[0], y[1]);
diff --git a/src/math/cosf.c b/src/math/cosf.c
index 4d94130..23f3e5b 100644
--- a/src/math/cosf.c
+++ b/src/math/cosf.c
@@ -26,34 +26,39 @@ c4pio2 = 4*M_PI_2; /* 0x401921FB, 0x54442D18 */
 float cosf(float x)
 {
 	double y;
-	int32_t n, hx, ix;
+	uint32_t ix;
+	unsigned n, sign;
+
+	GET_FLOAT_WORD(ix, x);
+	sign = ix >> 31;
+	ix &= 0x7fffffff;
 
-	GET_FLOAT_WORD(hx, x);
-	ix = hx & 0x7fffffff;
 	if (ix <= 0x3f490fda) {  /* |x| ~<= pi/4 */
-		if (ix < 0x39800000)  /* |x| < 2**-12 */
-			if ((int)x == 0)  /* raise inexact if x != 0 */
-				return 1.0;
+		if (ix < 0x39800000) {  /* |x| < 2**-12 */
+			/* raise inexact if x != 0 */
+			FORCE_EVAL(x + 0x1p120f);
+			return 1.0f;
+		}
 		return __cosdf(x);
 	}
 	if (ix <= 0x407b53d1) {  /* |x| ~<= 5*pi/4 */
 		if (ix > 0x4016cbe3)  /* |x|  ~> 3*pi/4 */
-			return -__cosdf(hx > 0 ? x-c2pio2 : x+c2pio2);
+			return -__cosdf(sign ? x+c2pio2 : x-c2pio2);
 		else {
-			if (hx > 0)
-				return __sindf(c1pio2 - x);
-			else
+			if (sign)
 				return __sindf(x + c1pio2);
+			else
+				return __sindf(c1pio2 - x);
 		}
 	}
 	if (ix <= 0x40e231d5) {  /* |x| ~<= 9*pi/4 */
 		if (ix > 0x40afeddf)  /* |x| ~> 7*pi/4 */
-			return __cosdf(hx > 0 ? x-c4pio2 : x+c4pio2);
+			return __cosdf(sign ? x+c4pio2 : x-c4pio2);
 		else {
-			if (hx > 0)
-				return __sindf(x - c3pio2);
+			if (sign)
+				return __sindf(-x - c3pio2);
 			else
-				return __sindf(-c3pio2 - x);
+				return __sindf(x - c3pio2);
 		}
 	}
 
diff --git a/src/math/cosl.c b/src/math/cosl.c
index 25d9005..0794d28 100644
--- a/src/math/cosl.c
+++ b/src/math/cosl.c
@@ -39,30 +39,30 @@ long double cosl(long double x) {
 long double cosl(long double x)
 {
 	union IEEEl2bits z;
-	int e0;
+	unsigned n;
 	long double y[2];
 	long double hi, lo;
 
 	z.e = x;
 	z.bits.sign = 0;
 
-	/* If x = +-0 or x is a subnormal number, then cos(x) = 1 */
-	if (z.bits.exp == 0)
-		return 1.0;
-
 	/* If x = NaN or Inf, then cos(x) = NaN. */
-	if (z.bits.exp == 32767)
+	if (z.bits.exp == 0x7fff)
 		return (x - x) / (x - x);
 
-	/* Optimize the case where x is already within range. */
-	if (z.e < M_PI_4)
+	/* |x| < (double)pi/4 */
+	if (z.e < M_PI_4) {
+		/* |x| < 0x1p-64 */
+		if (z.bits.exp < 0x3fff - 64)
+			/* raise inexact if x!=0 */
+			return 1.0 + x;
 		return __cosl(z.e, 0);
+	}
 
-	e0 = __rem_pio2l(x, y);
+	n = __rem_pio2l(x, y);
 	hi = y[0];
 	lo = y[1];
-
-	switch (e0 & 3) {
+	switch (n & 3) {
 	case 0:
 		hi = __cosl(hi, lo);
 		break;
diff --git a/src/math/sin.c b/src/math/sin.c
index 8e430f8..055e215 100644
--- a/src/math/sin.c
+++ b/src/math/sin.c
@@ -44,21 +44,22 @@
 
 double sin(double x)
 {
-	double y[2], z=0.0;
-	int32_t n, ix;
+	double y[2];
+	uint32_t ix;
+	unsigned n;
 
 	/* High word of x. */
 	GET_HIGH_WORD(ix, x);
+	ix &= 0x7fffffff;
 
 	/* |x| ~< pi/4 */
-	ix &= 0x7fffffff;
 	if (ix <= 0x3fe921fb) {
 		if (ix < 0x3e500000) {  /* |x| < 2**-26 */
-			/* raise inexact if x != 0 */
-			if ((int)x == 0)
-				return x;
+			/* raise inexact if x != 0 and underflow if subnormal*/
+			FORCE_EVAL(ix < 0x00100000 ? x/0x1p120f : x+0x1p120f);
+			return x;
 		}
-		return __sin(x, z, 0);
+		return __sin(x, 0.0, 0);
 	}
 
 	/* sin(Inf or NaN) is NaN */
diff --git a/src/math/sincos.c b/src/math/sincos.c
index 442e285..49f8a09 100644
--- a/src/math/sincos.c
+++ b/src/math/sincos.c
@@ -15,7 +15,8 @@
 void sincos(double x, double *sin, double *cos)
 {
 	double y[2], s, c;
-	uint32_t n, ix;
+	uint32_t ix;
+	unsigned n;
 
 	GET_HIGH_WORD(ix, x);
 	ix &= 0x7fffffff;
@@ -24,11 +25,10 @@ void sincos(double x, double *sin, double *cos)
 	if (ix <= 0x3fe921fb) {
 		/* if |x| < 2**-27 * sqrt(2) */
 		if (ix < 0x3e46a09e) {
-			/* raise inexact if x != 0 */
-			if ((int)x == 0) {
-				*sin = x;
-				*cos = 1.0;
-			}
+			/* raise inexact if x!=0 and underflow if subnormal */
+			FORCE_EVAL(ix < 0x00100000 ? x/0x1p120f : x+0x1p120f);
+			*sin = x;
+			*cos = 1.0;
 			return;
 		}
 		*sin = __sin(x, 0.0, 0);
diff --git a/src/math/sincosf.c b/src/math/sincosf.c
index 5e3b9a4..1b50f01 100644
--- a/src/math/sincosf.c
+++ b/src/math/sincosf.c
@@ -25,21 +25,23 @@ s4pio2 = 4*M_PI_2; /* 0x401921FB, 0x54442D18 */
 
 void sincosf(float x, float *sin, float *cos)
 {
-	double y, s, c;
-	uint32_t n, hx, ix;
+	double y;
+	float_t s, c;
+	uint32_t ix;
+	unsigned n, sign;
 
-	GET_FLOAT_WORD(hx, x);
-	ix = hx & 0x7fffffff;
+	GET_FLOAT_WORD(ix, x);
+	sign = ix >> 31;
+	ix &= 0x7fffffff;
 
 	/* |x| ~<= pi/4 */
 	if (ix <= 0x3f490fda) {
 		/* |x| < 2**-12 */
 		if (ix < 0x39800000) {
-			/* raise inexact if x != 0 */
-			if((int)x == 0) {
-				*sin = x;
-				*cos = 1.0f;
-			}
+			/* raise inexact if x!=0 and underflow if subnormal */
+			FORCE_EVAL(ix < 0x00100000 ? x/0x1p120f : x+0x1p120f);
+			*sin = x;
+			*cos = 1.0f;
 			return;
 		}
 		*sin = __sindf(x);
@@ -50,34 +52,35 @@ void sincosf(float x, float *sin, float *cos)
 	/* |x| ~<= 5*pi/4 */
 	if (ix <= 0x407b53d1) {
 		if (ix <= 0x4016cbe3) {  /* |x| ~<= 3pi/4 */
-			if (hx < 0x80000000) {
-				*sin = __cosdf(x - s1pio2);
-				*cos = __sindf(s1pio2 - x);
-			} else {
+			if (sign) {
 				*sin = -__cosdf(x + s1pio2);
 				*cos = __sindf(x + s1pio2);
+			} else {
+				*sin = __cosdf(s1pio2 - x);
+				*cos = __sindf(s1pio2 - x);
 			}
 			return;
 		}
-		*sin = __sindf(hx < 0x80000000 ? s2pio2 - x : -s2pio2 - x);
-		*cos = -__cosdf(hx < 0x80000000 ? x - s2pio2 : x + s2pio2);
+		/* -sin(x+c) is not correct if x+c could be 0: -0 vs +0 */
+		*sin = -__sindf(sign ? x + s2pio2 : x - s2pio2);
+		*cos = -__cosdf(sign ? x + s2pio2 : x - s2pio2);
 		return;
 	}
 
 	/* |x| ~<= 9*pi/4 */
 	if (ix <= 0x40e231d5) {
 		if (ix <= 0x40afeddf) {  /* |x| ~<= 7*pi/4 */
-			if (hx < 0x80000000) {
+			if (sign) {
+				*sin = __cosdf(x + s3pio2);
+				*cos = -__sindf(x + s3pio2);
+			} else {
 				*sin = -__cosdf(x - s3pio2);
 				*cos = __sindf(x - s3pio2);
-			} else {
-				*sin = __cosdf(x + s3pio2);
-				*cos = __sindf(-s3pio2 - x);
 			}
 			return;
 		}
-		*sin = __sindf(hx < 0x80000000 ? x - s4pio2 : x + s4pio2);
-		*cos = __cosdf(hx < 0x80000000 ? x - s4pio2 : x + s4pio2);
+		*sin = __sindf(sign ? x + s4pio2 : x - s4pio2);
+		*cos = __cosdf(sign ? x + s4pio2 : x - s4pio2);
 		return;
 	}
 
diff --git a/src/math/sincosl.c b/src/math/sincosl.c
index d632fe6..5db69bd 100644
--- a/src/math/sincosl.c
+++ b/src/math/sincosl.c
@@ -10,27 +10,29 @@ void sincosl(long double x, long double *sin, long double *cos)
 void sincosl(long double x, long double *sin, long double *cos)
 {
 	union IEEEl2bits u;
-	int n;
+	unsigned n;
 	long double y[2], s, c;
 
 	u.e = x;
 	u.bits.sign = 0;
 
-	/* x = +-0 or subnormal */
-	if (!u.bits.exp) {
-		*sin = x;
-		*cos = 1.0;
-		return;
-	}
-
 	/* x = nan or inf */
 	if (u.bits.exp == 0x7fff) {
 		*sin = *cos = x - x;
 		return;
 	}
 
-	/* |x| < pi/4 */
+	/* |x| < (double)pi/4 */
 	if (u.e < M_PI_4) {
+		/* |x| < 0x1p-64 */
+		if (u.bits.exp < 0x3fff - 64) {
+			/* raise underflow if subnormal */
+			if (u.bits.exp == 0) FORCE_EVAL(x*0x1p-120f);
+			*sin = x;
+			/* raise inexact if x!=0 */
+			*cos = 1.0 + x;
+			return;
+		}
 		*sin = __sinl(x, 0, 0);
 		*cos = __cosl(x, 0);
 		return;
diff --git a/src/math/sinf.c b/src/math/sinf.c
index dcca67a..64e39f5 100644
--- a/src/math/sinf.c
+++ b/src/math/sinf.c
@@ -26,35 +26,38 @@ s4pio2 = 4*M_PI_2; /* 0x401921FB, 0x54442D18 */
 float sinf(float x)
 {
 	double y;
-	int32_t n, hx, ix;
+	uint32_t ix;
+	int n, sign;
 
-	GET_FLOAT_WORD(hx, x);
-	ix = hx & 0x7fffffff;
+	GET_FLOAT_WORD(ix, x);
+	sign = ix >> 31;
+	ix &= 0x7fffffff;
 
 	if (ix <= 0x3f490fda) {  /* |x| ~<= pi/4 */
-		if (ix < 0x39800000)  /* |x| < 2**-12 */
-			/* raise inexact if x != 0 */
-			if((int)x == 0)
-				return x;
+		if (ix < 0x39800000) {  /* |x| < 2**-12 */
+			/* raise inexact if x!=0 and underflow if subnormal */
+			FORCE_EVAL(ix < 0x00800000 ? x/0x1p120f : x+0x1p120f);
+			return x;
+		}
 		return __sindf(x);
 	}
 	if (ix <= 0x407b53d1) {  /* |x| ~<= 5*pi/4 */
 		if (ix <= 0x4016cbe3) {  /* |x| ~<= 3pi/4 */
-			if (hx > 0)
-				return __cosdf(x - s1pio2);
-			else
+			if (sign)
 				return -__cosdf(x + s1pio2);
+			else
+				return __cosdf(x - s1pio2);
 		}
-		return __sindf(hx > 0 ? s2pio2 - x : -s2pio2 - x);
+		return __sindf(sign ? -(x + s2pio2) : -(x - s2pio2));
 	}
 	if (ix <= 0x40e231d5) {  /* |x| ~<= 9*pi/4 */
 		if (ix <= 0x40afeddf) {  /* |x| ~<= 7*pi/4 */
-			if (hx > 0)
-				return -__cosdf(x - s3pio2);
-			else
+			if (sign)
 				return __cosdf(x + s3pio2);
+			else
+				return -__cosdf(x - s3pio2);
 		}
-		return __sindf(hx > 0 ? x - s4pio2 : x + s4pio2);
+		return __sindf(sign ? x + s4pio2 : x - s4pio2);
 	}
 
 	/* sin(Inf or NaN) is NaN */
diff --git a/src/math/sinl.c b/src/math/sinl.c
index 7e0b44f..6ca9998 100644
--- a/src/math/sinl.c
+++ b/src/math/sinl.c
@@ -37,33 +37,32 @@ long double sinl(long double x)
 long double sinl(long double x)
 {
 	union IEEEl2bits z;
-	int e0, s;
+	unsigned n;
 	long double y[2];
 	long double hi, lo;
 
 	z.e = x;
-	s = z.bits.sign;
 	z.bits.sign = 0;
 
-	/* If x = +-0 or x is a subnormal number, then sin(x) = x */
-	if (z.bits.exp == 0)
-		return x;
-
 	/* If x = NaN or Inf, then sin(x) = NaN. */
-	if (z.bits.exp == 32767)
+	if (z.bits.exp == 0x7fff)
 		return (x - x) / (x - x);
 
-	/* Optimize the case where x is already within range. */
+	/* |x| < (double)pi/4 */
 	if (z.e < M_PI_4) {
-		hi = __sinl(z.e, 0, 0);
-		return  s ? -hi : hi;
+		/* |x| < 0x1p-64 */
+		if (z.bits.exp < 0x3fff - 64) {
+			/* raise inexact if x!=0 and underflow if subnormal */
+			FORCE_EVAL(z.bits.exp == 0 ? x/0x1p120f : x+0x1p120f);
+			return x;
+		}
+		return __sinl(x, 0.0, 0);
 	}
 
-	e0 = __rem_pio2l(x, y);
+	n = __rem_pio2l(x, y);
 	hi = y[0];
 	lo = y[1];
-
-	switch (e0 & 3) {
+	switch (n & 3) {
 	case 0:
 		hi = __sinl(hi, lo, 1);
 		break;
@@ -71,10 +70,10 @@ long double sinl(long double x)
 		hi = __cosl(hi, lo);
 		break;
 	case 2:
-		hi = - __sinl(hi, lo, 1);
+		hi = -__sinl(hi, lo, 1);
 		break;
 	case 3:
-		hi = - __cosl(hi, lo);
+		hi = -__cosl(hi, lo);
 		break;
 	}
 	return hi;
diff --git a/src/math/tanl.c b/src/math/tanl.c
index 3b51e01..546c7a0 100644
--- a/src/math/tanl.c
+++ b/src/math/tanl.c
@@ -53,11 +53,12 @@ long double tanl(long double x)
 
 	/* |x| < (double)pi/4 */
 	if (z.e < M_PI_4) {
-		/* x = +-0 or x is subnormal */
-		if (z.bits.exp == 0)
-			/* inexact and underflow if x!=0 */
-			return x + x*0x1p-120f;
-		/* can raise spurious underflow */
+		/* |x| < 0x1p-64 */
+		if (z.bits.exp < 0x3fff - 64) {
+			/* raise inexact if x!=0 and underflow if subnormal */
+			FORCE_EVAL(z.bits.exp == 0 ? x/0x1p120f : x+0x1p120f);
+			return x;
+		}
 		return __tanl(x, 0, 0);
 	}
 
-- 
1.7.2.5


From ffd8ac2dd50f99c3c83d7d9d845df9874ec3e7d5 Mon Sep 17 00:00:00 2001
From: Szabolcs Nagy <nsz@port70.net>
Date: Sun, 19 May 2013 12:13:08 +0000
Subject: [PATCH 29/53] math: fix two fma issues (only affects non-nearest rounding mode, x86)

1) in downward rounding fma(1,1,-1) should be -0 but it was 0 with
gcc, the code was correct but gcc does not support FENV_ACCESS ON
so it used common subexpression elimination where it shouldn't have.
now volatile memory access is used as a barrier after fesetround.

2) in directed rounding modes there is no double rounding issue
so the complicated adjustments done for nearest rounding mode are
not needed. the only exception to this rule is raising the underflow
flag: assume "small" is an exactly representible subnormal value in
double precision and "verysmall" is a much smaller value so that
	(long double)(small plus verysmall) == small
then
	(double)(small plus verysmall)
raises underflow because the result is an inexact subnormal, but
	(double)(long double)(small plus verysmall)
does not because small is not a subnormal in long double precision
and it is exact in double precision.
now this problem is fixed by checking inexact using fenv when the
result is subnormal
---
 src/math/fma.c |   42 ++++++++++++++++++++++++++++++++++++++----
 1 files changed, 38 insertions(+), 4 deletions(-)

diff --git a/src/math/fma.c b/src/math/fma.c
index 17f1cdc..89def79 100644
--- a/src/math/fma.c
+++ b/src/math/fma.c
@@ -119,9 +119,17 @@ double fma(double x, double y, double z)
 	} else if (ez > exy - 12) {
 		add(&hi, &lo2, xy, z);
 		if (hi == 0) {
+			/*
+			xy + z is 0, but it should be calculated with the
+			original rounding mode so the sign is correct, if the
+			compiler does not support FENV_ACCESS ON it does not
+			know about the changed rounding mode and eliminates
+			the xy + z below without the volatile memory access
+			*/
+			volatile double z_;
 			fesetround(round);
-			/* make sure that the sign of 0 is correct */
-			return (xy + z) + lo1;
+			z_ = z;
+			return (xy + z_) + lo1;
 		}
 	} else {
 		/*
@@ -135,10 +143,36 @@ double fma(double x, double y, double z)
 		hi = xy;
 		lo2 = z;
 	}
+	/*
+	the result is stored before return for correct precision and exceptions
+
+	one corner case is when the underflow flag should be raised because
+	the precise result is an inexact subnormal double, but the calculated
+	long double result is an exact subnormal double
+	(so rounding to double does not raise exceptions)
+
+	in nearest rounding mode dadd takes care of this: the last bit of the
+	result is adjusted so rounding sees an inexact value when it should
+
+	in non-nearest rounding mode fenv is used for the workaround
+	*/
 	fesetround(round);
 	if (round == FE_TONEAREST)
-		return dadd(hi, dadd(lo1, lo2));
-	return hi + (lo1 + lo2);
+		z = dadd(hi, dadd(lo1, lo2));
+	else {
+#if defined(FE_INEXACT) && defined(FE_UNDERFLOW)
+		int e = fetestexcept(FE_INEXACT);
+		feclearexcept(FE_INEXACT);
+#endif
+		z = hi + (lo1 + lo2);
+#if defined(FE_INEXACT) && defined(FE_UNDERFLOW)
+		if (getexp(z) < 0x3fff-1022 && fetestexcept(FE_INEXACT))
+			feraiseexcept(FE_UNDERFLOW);
+		else if (e)
+			feraiseexcept(FE_INEXACT);
+#endif
+	}
+	return z;
 }
 #else
 /* origin: FreeBSD /usr/src/lib/msun/src/s_fma.c */
-- 
1.7.2.5


From 1e5eb73545ca6cfe8b918798835aaf6e07af5beb Mon Sep 17 00:00:00 2001
From: Szabolcs Nagy <nsz@port70.net>
Date: Sun, 19 May 2013 14:43:32 +0000
Subject: [PATCH 30/53] math: add fma TODO comments about the underflow issue

The underflow exception is not raised correctly in some
cornercases (see previous fma commit), added comments
with examples for fmaf, fmal and non-x86 fma.

In fmaf store the result before returning so it has the
correct precision when FLT_EVAL_METHOD!=0
---
 src/math/fma.c  |    2 ++
 src/math/fmaf.c |   12 ++++++++++--
 src/math/fmal.c |    2 ++
 3 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/src/math/fma.c b/src/math/fma.c
index 89def79..850a4a6 100644
--- a/src/math/fma.c
+++ b/src/math/fma.c
@@ -441,6 +441,8 @@ double fma(double x, double y, double z)
 		/*
 		 * There is no need to worry about double rounding in directed
 		 * rounding modes.
+		 * TODO: underflow is not raised properly, example in downward rounding:
+		 * fma(0x1.000000001p-1000, 0x1.000000001p-30, -0x1p-1066)
 		 */
 		fesetround(oround);
 		adj = r.lo + xy.lo;
diff --git a/src/math/fmaf.c b/src/math/fmaf.c
index a1c7f4f..745ee39 100644
--- a/src/math/fmaf.c
+++ b/src/math/fmaf.c
@@ -49,7 +49,14 @@ float fmaf(float x, float y, float z)
 		(hr & 0x7ff00000) == 0x7ff00000 ||  /* NaN */
 		result - xy == z ||                 /* exact */
 		fegetround() != FE_TONEAREST)       /* not round-to-nearest */
-		return (result);
+	{
+		/*
+		TODO: underflow is not raised correctly, example in
+		downward rouding: fmaf(0x1p-120f, 0x1p-120f, 0x1p-149f)
+		*/
+		z = result;
+		return z;
+	}
 
 	/*
 	 * If result is inexact, and exactly halfway between two float values,
@@ -63,5 +70,6 @@ float fmaf(float x, float y, float z)
 	fesetround(FE_TONEAREST);
 	if (result == adjusted_result)
 		SET_LOW_WORD(adjusted_result, lr + 1);
-	return (adjusted_result);
+	z = adjusted_result;
+	return z;
 }
diff --git a/src/math/fmal.c b/src/math/fmal.c
index ccbe434..87e30fc 100644
--- a/src/math/fmal.c
+++ b/src/math/fmal.c
@@ -262,6 +262,8 @@ long double fmal(long double x, long double y, long double z)
 		/*
 		 * There is no need to worry about double rounding in directed
 		 * rounding modes.
+		 * TODO: underflow is not raised correctly, example in downward rounding:
+		 * fmal(0x1.0000000001p-16000L, 0x1.0000000001p-400L, -0x1p-16440L)
 		 */
 		fesetround(oround);
 		adj = r.lo + xy.lo;
-- 
1.7.2.5


From 05453b37fc0343e53bc7f332047e901b3e1abb84 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Thu, 23 May 2013 14:31:02 -0400
Subject: [PATCH 31/53] fix overflow behavior of clock() function

per Austin Group interpretation for issue #686, which cites the
requirements of ISO C, clock() cannot wrap. if the result is not
representable, it must return (clock_t)-1. in addition, the old code
was performing wrapping via signed overflow and thus invoking
undefined behavior.

since it seems impossible to accurately check for overflow with the
old times()-based fallback code, I have simply dropped the fallback
code for now, thus always returning -1 on ancient systems. if there's
a demand for making it work and somebody comes up with a way, it could
be reinstated, but the clock() function is essentially useless on
32-bit system anyway (it overflows in less than an hour).

it should be noted that I used LONG_MAX rather than ULONG_MAX, despite
32-bit archs using an unsigned type for clock_t. this discrepency with
the glibc/LSB type definitions will be fixed now; since wrapping of
clock_t is no longer supported, there's no use in it being unsigned.
---
 src/time/clock.c |   17 ++++++++++-------
 1 files changed, 10 insertions(+), 7 deletions(-)

diff --git a/src/time/clock.c b/src/time/clock.c
index 78403af..c348e39 100644
--- a/src/time/clock.c
+++ b/src/time/clock.c
@@ -1,15 +1,18 @@
 #include <time.h>
-#include <sys/times.h>
-#include "syscall.h"
+#include <limits.h>
 
 int __clock_gettime(clockid_t, struct timespec *);
 
 clock_t clock()
 {
 	struct timespec ts;
-	struct tms tms;
-	if (!__clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts))
-		return ts.tv_sec*1000000 + ts.tv_nsec/1000;
-	__syscall(SYS_times, &tms);
-	return (tms.tms_utime + tms.tms_stime)*10000;
+
+	if (__clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts))
+		return -1;
+
+	if (ts.tv_sec > LONG_MAX/1000000
+	 || ts.tv_nsec/1000 > LONG_MAX-1000000*ts.tv_sec)
+		return -1;
+
+	return ts.tv_sec*1000000 + ts.tv_nsec/1000;
 }
-- 
1.7.2.5


From 5e642b5a2395893873affa2a121a694943b3f4e0 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Thu, 23 May 2013 20:38:51 -0400
Subject: [PATCH 32/53] change underlying type of clock_t to be uniform and match ABI

previously we were using an unsigned type on 32-bit systems so that
subtraction would be well-defined when it wrapped, but since wrapping
is non-conforming anyway (when clock() overflows, it has to return -1)
the only use of unsigned would be to buy a little bit more time before
overflow. this does not seem worth having the type vary per-arch
(which leads to more arch-specific bugs) or disagree with the ABI musl
(mostly) follows.
---
 arch/arm/bits/alltypes.h.sh        |    2 +-
 arch/i386/bits/alltypes.h.sh       |    2 +-
 arch/microblaze/bits/alltypes.h.sh |    2 +-
 arch/mips/bits/alltypes.h.sh       |    2 +-
 arch/powerpc/bits/alltypes.h.sh    |    2 +-
 5 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/arch/arm/bits/alltypes.h.sh b/arch/arm/bits/alltypes.h.sh
index c1db1a0..62e0327 100755
--- a/arch/arm/bits/alltypes.h.sh
+++ b/arch/arm/bits/alltypes.h.sh
@@ -104,7 +104,7 @@ TYPEDEF unsigned long long fsfilcnt_t;
 
 TYPEDEF void * timer_t;
 TYPEDEF int clockid_t;
-TYPEDEF unsigned long clock_t;
+TYPEDEF long clock_t;
 
 TYPEDEF struct { unsigned long __bits[128/sizeof(long)]; } sigset_t;
 TYPEDEF struct __siginfo siginfo_t;
diff --git a/arch/i386/bits/alltypes.h.sh b/arch/i386/bits/alltypes.h.sh
index aec7373..76c50ec 100755
--- a/arch/i386/bits/alltypes.h.sh
+++ b/arch/i386/bits/alltypes.h.sh
@@ -117,7 +117,7 @@ TYPEDEF unsigned long long fsfilcnt_t;
 
 TYPEDEF void * timer_t;
 TYPEDEF int clockid_t;
-TYPEDEF unsigned long clock_t;
+TYPEDEF long clock_t;
 
 TYPEDEF struct { unsigned long __bits[128/sizeof(long)]; } sigset_t;
 TYPEDEF struct __siginfo siginfo_t;
diff --git a/arch/microblaze/bits/alltypes.h.sh b/arch/microblaze/bits/alltypes.h.sh
index 23f12d8..268321a 100755
--- a/arch/microblaze/bits/alltypes.h.sh
+++ b/arch/microblaze/bits/alltypes.h.sh
@@ -104,7 +104,7 @@ TYPEDEF unsigned long long fsfilcnt_t;
 
 TYPEDEF void * timer_t;
 TYPEDEF int clockid_t;
-TYPEDEF unsigned long clock_t;
+TYPEDEF long clock_t;
 
 TYPEDEF struct { unsigned long __bits[128/sizeof(long)]; } sigset_t;
 TYPEDEF struct __siginfo siginfo_t;
diff --git a/arch/mips/bits/alltypes.h.sh b/arch/mips/bits/alltypes.h.sh
index 23f12d8..268321a 100755
--- a/arch/mips/bits/alltypes.h.sh
+++ b/arch/mips/bits/alltypes.h.sh
@@ -104,7 +104,7 @@ TYPEDEF unsigned long long fsfilcnt_t;
 
 TYPEDEF void * timer_t;
 TYPEDEF int clockid_t;
-TYPEDEF unsigned long clock_t;
+TYPEDEF long clock_t;
 
 TYPEDEF struct { unsigned long __bits[128/sizeof(long)]; } sigset_t;
 TYPEDEF struct __siginfo siginfo_t;
diff --git a/arch/powerpc/bits/alltypes.h.sh b/arch/powerpc/bits/alltypes.h.sh
index 7d3cdc3..5fe05e2 100755
--- a/arch/powerpc/bits/alltypes.h.sh
+++ b/arch/powerpc/bits/alltypes.h.sh
@@ -104,7 +104,7 @@ TYPEDEF unsigned long long fsfilcnt_t;
 
 TYPEDEF void * timer_t;
 TYPEDEF int clockid_t;
-TYPEDEF unsigned long clock_t;
+TYPEDEF long clock_t;
 
 TYPEDEF struct { unsigned long __bits[128/sizeof(long)]; } sigset_t;
 TYPEDEF struct __siginfo siginfo_t;
-- 
1.7.2.5


From a6367a17d5f77848e8313b1e5e42698aec92908d Mon Sep 17 00:00:00 2001
From: Szabolcs Nagy <nsz@port70.net>
Date: Sun, 26 May 2013 15:43:17 +0000
Subject: [PATCH 33/53] on x86_64 use long instead of long long for 64bit posix types

following glibc use the lowest rank 64bit integer type for ino_t etc.
this is eg. useful for printf format compatibility
---
 arch/x86_64/bits/alltypes.h.sh |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/arch/x86_64/bits/alltypes.h.sh b/arch/x86_64/bits/alltypes.h.sh
index c5e54aa..a6c9032 100755
--- a/arch/x86_64/bits/alltypes.h.sh
+++ b/arch/x86_64/bits/alltypes.h.sh
@@ -94,12 +94,12 @@ TYPEDEF long off_t;
 TYPEDEF unsigned int mode_t;
 
 TYPEDEF unsigned long nlink_t;
-TYPEDEF unsigned long long ino_t;
+TYPEDEF unsigned long ino_t;
 TYPEDEF unsigned long dev_t;
 TYPEDEF long blksize_t;
-TYPEDEF long long blkcnt_t;
-TYPEDEF unsigned long long fsblkcnt_t;
-TYPEDEF unsigned long long fsfilcnt_t;
+TYPEDEF long blkcnt_t;
+TYPEDEF unsigned long fsblkcnt_t;
+TYPEDEF unsigned long fsfilcnt_t;
 
 TYPEDEF void * timer_t;
 TYPEDEF int clockid_t;
-- 
1.7.2.5


From 41c34d188a598b016d62e152735f8466fe9910a4 Mon Sep 17 00:00:00 2001
From: Szabolcs Nagy <nsz@port70.net>
Date: Sun, 26 May 2013 15:49:08 +0000
Subject: [PATCH 34/53] fix ioctl _IOR, _IOW, etc macros to avoid signed overflow (2<<30)

---
 arch/arm/bits/ioctl.h        |    6 +++---
 arch/i386/bits/ioctl.h       |    6 +++---
 arch/microblaze/bits/ioctl.h |    6 +++---
 arch/mips/bits/ioctl.h       |    8 ++++----
 arch/powerpc/bits/ioctl.h    |   25 +++----------------------
 arch/x86_64/bits/ioctl.h     |    6 +++---
 6 files changed, 19 insertions(+), 38 deletions(-)

diff --git a/arch/arm/bits/ioctl.h b/arch/arm/bits/ioctl.h
index 336c71c..9d75118 100644
--- a/arch/arm/bits/ioctl.h
+++ b/arch/arm/bits/ioctl.h
@@ -4,9 +4,9 @@
 #define _IOC_READ  2U
 
 #define _IO(a,b) _IOC(_IOC_NONE,(a),(b),0)
-#define _IOW(a,b,c) _IOC(1,(a),(b),sizeof(c))
-#define _IOR(a,b,c) _IOC(2,(a),(b),sizeof(c))
-#define _IOWR(a,b,c) _IOC(3,(a),(b),sizeof(c))
+#define _IOW(a,b,c) _IOC(_IOC_WRITE,(a),(b),sizeof(c))
+#define _IOR(a,b,c) _IOC(_IOC_READ,(a),(b),sizeof(c))
+#define _IOWR(a,b,c) _IOC(_IOC_READ|_IOC_WRITE,(a),(b),sizeof(c))
 
 #define TCGETS		0x5401
 #define TCSETS		0x5402
diff --git a/arch/i386/bits/ioctl.h b/arch/i386/bits/ioctl.h
index 336c71c..9d75118 100644
--- a/arch/i386/bits/ioctl.h
+++ b/arch/i386/bits/ioctl.h
@@ -4,9 +4,9 @@
 #define _IOC_READ  2U
 
 #define _IO(a,b) _IOC(_IOC_NONE,(a),(b),0)
-#define _IOW(a,b,c) _IOC(1,(a),(b),sizeof(c))
-#define _IOR(a,b,c) _IOC(2,(a),(b),sizeof(c))
-#define _IOWR(a,b,c) _IOC(3,(a),(b),sizeof(c))
+#define _IOW(a,b,c) _IOC(_IOC_WRITE,(a),(b),sizeof(c))
+#define _IOR(a,b,c) _IOC(_IOC_READ,(a),(b),sizeof(c))
+#define _IOWR(a,b,c) _IOC(_IOC_READ|_IOC_WRITE,(a),(b),sizeof(c))
 
 #define TCGETS		0x5401
 #define TCSETS		0x5402
diff --git a/arch/microblaze/bits/ioctl.h b/arch/microblaze/bits/ioctl.h
index 336c71c..9d75118 100644
--- a/arch/microblaze/bits/ioctl.h
+++ b/arch/microblaze/bits/ioctl.h
@@ -4,9 +4,9 @@
 #define _IOC_READ  2U
 
 #define _IO(a,b) _IOC(_IOC_NONE,(a),(b),0)
-#define _IOW(a,b,c) _IOC(1,(a),(b),sizeof(c))
-#define _IOR(a,b,c) _IOC(2,(a),(b),sizeof(c))
-#define _IOWR(a,b,c) _IOC(3,(a),(b),sizeof(c))
+#define _IOW(a,b,c) _IOC(_IOC_WRITE,(a),(b),sizeof(c))
+#define _IOR(a,b,c) _IOC(_IOC_READ,(a),(b),sizeof(c))
+#define _IOWR(a,b,c) _IOC(_IOC_READ|_IOC_WRITE,(a),(b),sizeof(c))
 
 #define TCGETS		0x5401
 #define TCSETS		0x5402
diff --git a/arch/mips/bits/ioctl.h b/arch/mips/bits/ioctl.h
index 5040226..83fb167 100644
--- a/arch/mips/bits/ioctl.h
+++ b/arch/mips/bits/ioctl.h
@@ -3,10 +3,10 @@
 #define _IOC_READ  2U
 #define _IOC_WRITE 4U
 
-#define _IO(a,b) _IOC(1U,(a),(b),0)
-#define _IOW(a,b,c) _IOC(4U,(a),(b),sizeof(c))
-#define _IOR(a,b,c) _IOC(2U,(a),(b),sizeof(c))
-#define _IOWR(a,b,c) _IOC(6U,(a),(b),sizeof(c))
+#define _IO(a,b) _IOC(_IOC_NONE,(a),(b),0)
+#define _IOW(a,b,c) _IOC(_IOC_WRITE,(a),(b),sizeof(c))
+#define _IOR(a,b,c) _IOC(_IOC_READ,(a),(b),sizeof(c))
+#define _IOWR(a,b,c) _IOC(_IOC_READ|_IOC_WRITE,(a),(b),sizeof(c))
 
 #define TCGETA		0x5401
 #define TCSETA		0x5402
diff --git a/arch/powerpc/bits/ioctl.h b/arch/powerpc/bits/ioctl.h
index 15cd6c7..0c903dc 100644
--- a/arch/powerpc/bits/ioctl.h
+++ b/arch/powerpc/bits/ioctl.h
@@ -1,31 +1,12 @@
-//#define _IOC(a,b,c,d) ( ((a)<<29) | ((b)<<8) | (c) | ((d)<<16) )
-//
-#define _IOC_SIZEBITS   13
-#define _IOC_DIRBITS    3
-
-#define _IOC_NRBITS     8
-#define _IOC_TYPEBITS   8
-
-#define _IOC_NRSHIFT    0
-#define _IOC_TYPESHIFT  (_IOC_NRSHIFT+_IOC_NRBITS)
-#define _IOC_SIZESHIFT  (_IOC_TYPESHIFT+_IOC_TYPEBITS)
-#define _IOC_DIRSHIFT   (_IOC_SIZESHIFT+_IOC_SIZEBITS)
-
-#define _IOC(dir,type,nr,size) \
-        (((dir)  << _IOC_DIRSHIFT) | \
-          ((type) << _IOC_TYPESHIFT) | \
-          ((nr)   << _IOC_NRSHIFT) | \
-          ((size) << _IOC_SIZESHIFT))
-
-
+#define _IOC(a,b,c,d) ( ((a)<<29) | ((b)<<8) | (c) | ((d)<<16) )
 #define _IOC_NONE  1U
 #define _IOC_WRITE 4U
 #define _IOC_READ  2U
 
 #define _IO(a,b) _IOC(_IOC_NONE,(a),(b),0)
 #define _IOW(a,b,c) _IOC(_IOC_WRITE,(a),(b),sizeof(c))
-#define _IOR(a,b,c) _IOC(_IOC_READ ,(a),(b),sizeof(c))
-#define _IOWR(a,b,c) _IOC(_IOC_READ | _IOC_WRITE,(a),(b),sizeof(c))
+#define _IOR(a,b,c) _IOC(_IOC_READ,(a),(b),sizeof(c))
+#define _IOWR(a,b,c) _IOC(_IOC_READ|_IOC_WRITE,(a),(b),sizeof(c))
 
 #define FIONCLEX	_IO('f', 2)
 #define FIOCLEX		_IO('f', 1)
diff --git a/arch/x86_64/bits/ioctl.h b/arch/x86_64/bits/ioctl.h
index 7f3c038..77a9455 100644
--- a/arch/x86_64/bits/ioctl.h
+++ b/arch/x86_64/bits/ioctl.h
@@ -4,9 +4,9 @@
 #define _IOC_READ  2U
 
 #define _IO(a,b) _IOC(_IOC_NONE,(a),(b),0)
-#define _IOW(a,b,c) _IOC(1,(a),(b),sizeof(c))
-#define _IOR(a,b,c) _IOC(2,(a),(b),sizeof(c))
-#define _IOWR(a,b,c) _IOC(3,(a),(b),sizeof(c))
+#define _IOW(a,b,c) _IOC(_IOC_WRITE,(a),(b),sizeof(c))
+#define _IOR(a,b,c) _IOC(_IOC_READ,(a),(b),sizeof(c))
+#define _IOWR(a,b,c) _IOC(_IOC_READ|_IOC_WRITE,(a),(b),sizeof(c))
 
 #define TCGETS		0x5401
 #define TCSETS		0x5402
-- 
1.7.2.5


From 31ff797787d89bc01a69ca672fb2340ff21a827e Mon Sep 17 00:00:00 2001
From: Szabolcs Nagy <nsz@port70.net>
Date: Sun, 26 May 2013 16:01:38 +0000
Subject: [PATCH 35/53] fix the prototype of settimeofday to follow the original BSD declaration

---
 include/sys/time.h       |   10 +++++-----
 src/linux/settimeofday.c |    3 ++-
 2 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/include/sys/time.h b/include/sys/time.h
index 559e817..3ce824e 100644
--- a/include/sys/time.h
+++ b/include/sys/time.h
@@ -30,15 +30,15 @@ int utimes (const char *, const struct timeval [2]);
 #endif
 
 #if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
-int futimes(int, const struct timeval [2]);
-int futimesat(int, const char *, const struct timeval [2]);
-int lutimes(const char *, const struct timeval [2]);
-int settimeofday (const struct timeval *, void *);
-int adjtime (const struct timeval *, struct timeval *);
 struct timezone {
 	int tz_minuteswest;
 	int tz_dsttime;
 };
+int futimes(int, const struct timeval [2]);
+int futimesat(int, const char *, const struct timeval [2]);
+int lutimes(const char *, const struct timeval [2]);
+int settimeofday(const struct timeval *, const struct timezone *);
+int adjtime (const struct timeval *, struct timeval *);
 #define timerisset(t) ((t)->tv_sec || (t)->tv_usec)
 #define timerclear(t) ((t)->tv_sec = (t)->tv_usec = 0)
 #define timercmp(s,t,op) ((s)->tv_sec == (t)->tv_sec ? \
diff --git a/src/linux/settimeofday.c b/src/linux/settimeofday.c
index d741f66..15c18c6 100644
--- a/src/linux/settimeofday.c
+++ b/src/linux/settimeofday.c
@@ -1,7 +1,8 @@
+#define _BSD_SOURCE
 #include <sys/time.h>
 #include "syscall.h"
 
-int settimeofday(const struct timeval *tv, void *tz)
+int settimeofday(const struct timeval *tv, const struct timezone *tz)
 {
 	return syscall(SYS_settimeofday, tv, 0);
 }
-- 
1.7.2.5


From 44b4d09fc0626541ca12cf96f65adc21ab1fc413 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Mon, 3 Jun 2013 16:35:59 -0400
Subject: [PATCH 36/53] ensure that thread dtv pointer is never null to optimize __tls_get_addr

---
 src/ldso/dynlink.c        |    8 ++++----
 src/thread/pthread_self.c |    2 ++
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/src/ldso/dynlink.c b/src/ldso/dynlink.c
index dec9511..ee5ec30 100644
--- a/src/ldso/dynlink.c
+++ b/src/ldso/dynlink.c
@@ -740,13 +740,13 @@ void *__copy_tls(unsigned char *mem)
 void *__tls_get_addr(size_t *v)
 {
 	pthread_t self = __pthread_self();
-	if (self->dtv && v[0]<=(size_t)self->dtv[0] && self->dtv[v[0]])
+	if (v[0]<=(size_t)self->dtv[0] && self->dtv[v[0]])
 		return (char *)self->dtv[v[0]]+v[1];
 
 	/* Block signals to make accessing new TLS async-signal-safe */
 	sigset_t set;
 	pthread_sigmask(SIG_BLOCK, SIGALL_SET, &set);
-	if (self->dtv && v[0]<=(size_t)self->dtv[0] && self->dtv[v[0]]) {
+	if (v[0]<=(size_t)self->dtv[0] && self->dtv[v[0]]) {
 		pthread_sigmask(SIG_SETMASK, &set, 0);
 		return (char *)self->dtv[v[0]]+v[1];
 	}
@@ -759,10 +759,10 @@ void *__tls_get_addr(size_t *v)
 	for (p=head; p->tls_id != v[0]; p=p->next);
 
 	/* Get new DTV space from new DSO if needed */
-	if (!self->dtv || v[0] > (size_t)self->dtv[0]) {
+	if (v[0] > (size_t)self->dtv[0]) {
 		void **newdtv = p->new_dtv +
 			(v[0]+1)*sizeof(void *)*a_fetch_add(&p->new_dtv_idx,1);
-		if (self->dtv) memcpy(newdtv, self->dtv,
+		memcpy(newdtv, self->dtv,
 			((size_t)self->dtv[0]+1) * sizeof(void *));
 		newdtv[0] = (void *)v[0];
 		self->dtv = newdtv;
diff --git a/src/thread/pthread_self.c b/src/thread/pthread_self.c
index c50a2fb..aed4b5f 100644
--- a/src/thread/pthread_self.c
+++ b/src/thread/pthread_self.c
@@ -17,6 +17,8 @@ static int init_main_thread()
 	main_thread->self = main_thread;
 	main_thread->tid = main_thread->pid =
 		__syscall(SYS_set_tid_address, &main_thread->tid);
+	if (!main_thread->dtv)
+		main_thread->dtv = (void *)dummy;
 	libc.main_thread = main_thread;
 	return 0;
 }
-- 
1.7.2.5


From a6d272127bb6a2eb09dc182cc39c49e77310ade4 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Mon, 3 Jun 2013 17:32:42 -0400
Subject: [PATCH 37/53] align stack properly for calling global ctors/dtors on x86[_64]

failure to do so was causing crashes on x86_64 when ctors used SSE,
which was first observed when ctors called variadic functions due to
the SSE prologue code inserted into every variadic function.
---
 crt/i386/crti.s   |    2 ++
 crt/i386/crtn.s   |    2 ++
 crt/x86_64/crti.s |    2 ++
 crt/x86_64/crtn.s |    2 ++
 4 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/crt/i386/crti.s b/crt/i386/crti.s
index 2eb23ed..d2682a2 100644
--- a/crt/i386/crti.s
+++ b/crt/i386/crti.s
@@ -1,7 +1,9 @@
 .section .init
 .global _init
 _init:
+	sub $12,%esp
 
 .section .fini
 .global _fini
 _fini:
+	sub $12,%esp
diff --git a/crt/i386/crtn.s b/crt/i386/crtn.s
index 055451e..f3b61e0 100644
--- a/crt/i386/crtn.s
+++ b/crt/i386/crtn.s
@@ -1,5 +1,7 @@
 .section .init
+	add $12,%esp
 	ret
 
 .section .fini
+	add $12,%esp
 	ret
diff --git a/crt/x86_64/crti.s b/crt/x86_64/crti.s
index 2eb23ed..4788968 100644
--- a/crt/x86_64/crti.s
+++ b/crt/x86_64/crti.s
@@ -1,7 +1,9 @@
 .section .init
 .global _init
 _init:
+	push %rax
 
 .section .fini
 .global _fini
 _fini:
+	push %rax
diff --git a/crt/x86_64/crtn.s b/crt/x86_64/crtn.s
index 055451e..29198b7 100644
--- a/crt/x86_64/crtn.s
+++ b/crt/x86_64/crtn.s
@@ -1,5 +1,7 @@
 .section .init
+	pop %rax
 	ret
 
 .section .fini
+	pop %rax
 	ret
-- 
1.7.2.5


From f18846dd3a048598676e10b2a7b9f931bb3d1d6a Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Tue, 4 Jun 2013 16:09:36 -0400
Subject: [PATCH 38/53] refactor scanf core to use common code path for all string formats

the concept here is that %s and %c are essentially special-cases of
%[, with some minimal additional special-casing.

aside from simplifying the code and reducing the number of complex
code-paths that would need changing to make optimizations later, the
main purpose of this change is to simplify addition of the 'm'
modifier which causes scanf to allocate storage for the string being
read.
---
 src/stdio/vfscanf.c |  137 +++++++++++++++++++-------------------------------
 1 files changed, 52 insertions(+), 85 deletions(-)

diff --git a/src/stdio/vfscanf.c b/src/stdio/vfscanf.c
index fe071e9..62bf47f 100644
--- a/src/stdio/vfscanf.c
+++ b/src/stdio/vfscanf.c
@@ -88,6 +88,7 @@ int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 	unsigned long long x;
 	long double y;
 	off_t pos = 0;
+	unsigned char scanset[257];
 
 	FLOCK(f);
 
@@ -170,104 +171,92 @@ int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 
 		switch (t) {
 		case 'C':
+			if (width < 1) width = 1;
+		case 'S':
+			t |= 32;
+			size = SIZE_l;
+			break;
 		case 'c':
 			if (width < 1) width = 1;
-		case 's':
-			if (size == SIZE_l) t &= ~0x20;
 		case 'd': case 'i': case 'o': case 'u': case 'x':
 		case 'a': case 'e': case 'f': case 'g':
 		case 'A': case 'E': case 'F': case 'G': case 'X':
-		case '[': case 'S':
+		case '[': case 's':
 		case 'p': case 'n':
-			if (width < 1) width = 0;
 			break;
 		default:
 			goto fmt_fail;
 		}
 
-		shlim(f, width);
+		if (t == 'n') {
+			store_int(dest, size, pos);
+			/* do not increment match count, etc! */
+			continue;
+		}
 
-		if (t != 'n') {
-			if (shgetc(f) < 0) goto input_fail;
+		if (t != '[' && (t|32) != 'c') {
+			shlim(f, 0);
+			while (isspace(shgetc(f)));
 			shunget(f);
+			pos += shcnt(f);
 		}
 
+		shlim(f, width);
+		if (shgetc(f) < 0) goto input_fail;
+		shunget(f);
+
 		switch (t) {
-		case 'n':
-			store_int(dest, size, pos);
-			/* do not increment match count, etc! */
-			continue;
-		case 'C':
-			wcs = dest;
-			st = (mbstate_t){ 0 };
-			while ((c=shgetc(f)) >= 0) {
-				if (readwc(c, &wcs, &st) < 0)
-					goto input_fail;
-			}
-			if (!mbsinit(&st)) goto input_fail;
-			if (shcnt(f) != width) goto match_fail;
-			break;
+		case 's':
 		case 'c':
-			if (dest) {
-				s = dest;
-				while ((c=shgetc(f)) >= 0) *s++ = c;
-			} else {
-				while (shgetc(f)>=0);
-			}
-			if (shcnt(f) < width) goto match_fail;
-			break;
 		case '[':
-			s = dest;
-			wcs = dest;
-
-			if (*++p == '^') p++, invert = 1;
-			else invert = 0;
-
-			unsigned char scanset[257];
-			memset(scanset, invert, sizeof scanset);
-
-			scanset[0] = 0;
-			if (*p == '-') p++, scanset[1+'-'] = 1-invert;
-			else if (*p == ']') p++, scanset[1+']'] = 1-invert;
-			for (; *p != ']'; p++) {
-				if (!*p) goto fmt_fail;
-				if (*p=='-' && p[1] && p[1] != ']')
-					for (c=p++[-1]; c<*p; c++)
-						scanset[1+c] = 1-invert;
-				scanset[1+*p] = 1-invert;
+			if (t == 'c' || t == 's') {
+				memset(scanset, -1, sizeof scanset);
+				scanset[0] = 0;
+				if (t == 's') {
+					scanset[1+'\t'] = 0;
+					scanset[1+'\n'] = 0;
+					scanset[1+'\v'] = 0;
+					scanset[1+'\f'] = 0;
+					scanset[1+'\r'] = 0;
+					scanset[1+' '] = 0;
+				}
+			} else {
+				if (*++p == '^') p++, invert = 1;
+				else invert = 0;
+				memset(scanset, invert, sizeof scanset);
+				scanset[0] = 0;
+				if (*p == '-') p++, scanset[1+'-'] = 1-invert;
+				else if (*p == ']') p++, scanset[1+']'] = 1-invert;
+				for (; *p != ']'; p++) {
+					if (!*p) goto fmt_fail;
+					if (*p=='-' && p[1] && p[1] != ']')
+						for (c=p++[-1]; c<*p; c++)
+							scanset[1+c] = 1-invert;
+					scanset[1+*p] = 1-invert;
+				}
 			}
-
+			wcs = 0;
+			s = 0;
 			if (size == SIZE_l) {
+				wcs = dest;
 				st = (mbstate_t){0};
 				while (scanset[(c=shgetc(f))+1]) {
 					if (readwc(c, &wcs, &st) < 0)
 						goto input_fail;
 				}
 				if (!mbsinit(&st)) goto input_fail;
-				s = 0;
-			} else if (s) {
+			} else if ((s = dest)) {
 				while (scanset[(c=shgetc(f))+1])
 					*s++ = c;
-				wcs = 0;
 			} else {
 				while (scanset[(c=shgetc(f))+1]);
 			}
 			shunget(f);
 			if (!shcnt(f)) goto match_fail;
-			if (s) *s = 0;
+			if (t == 'c' && shcnt(f) != width) goto match_fail;
 			if (wcs) *wcs = 0;
+			if (s) *s = 0;
 			break;
-		default:
-			shlim(f, 0);
-			while (isspace(shgetc(f)));
-			shunget(f);
-			pos += shcnt(f);
-			shlim(f, width);
-			if (shgetc(f) < 0) goto input_fail;
-			shunget(f);
-		}
-
-		switch (t) {
 		case 'p':
 		case 'X':
 		case 'x':
@@ -306,28 +295,6 @@ int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 				break;
 			}
 			break;
-		case 'S':
-			wcs = dest;
-			st = (mbstate_t){ 0 };
-			while (!isspace(c=shgetc(f)) && c!=EOF) {
-				if (readwc(c, &wcs, &st) < 0)
-					goto input_fail;
-			}
-			shunget(f);
-			if (!mbsinit(&st)) goto input_fail;
-			if (dest) *wcs++ = 0;
-			break;
-		case 's':
-			if (dest) {
-				s = dest;
-				while (!isspace(c=shgetc(f)) && c!=EOF)
-					*s++ = c;
-				*s = 0;
-			} else {
-				while (!isspace(c=shgetc(f)) && c!=EOF);
-			}
-			shunget(f);
-			break;
 		}
 
 		pos += shcnt(f);
-- 
1.7.2.5


From 1ab59de81e94e7802f85d314a709f8350a0e9b65 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Tue, 4 Jun 2013 16:22:02 -0400
Subject: [PATCH 39/53] simplify some logic in scanf and remove redundant invalid-format check

---
 src/stdio/vfscanf.c |   26 ++++++++------------------
 1 files changed, 8 insertions(+), 18 deletions(-)

diff --git a/src/stdio/vfscanf.c b/src/stdio/vfscanf.c
index 62bf47f..d8f9ae6 100644
--- a/src/stdio/vfscanf.c
+++ b/src/stdio/vfscanf.c
@@ -169,32 +169,22 @@ int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 
 		t = *p;
 
-		switch (t) {
-		case 'C':
-			if (width < 1) width = 1;
-		case 'S':
+		/* C or S */
+		if ((t&0x2f) == 3) {
 			t |= 32;
 			size = SIZE_l;
-			break;
+		}
+
+		switch (t) {
 		case 'c':
 			if (width < 1) width = 1;
-		case 'd': case 'i': case 'o': case 'u': case 'x':
-		case 'a': case 'e': case 'f': case 'g':
-		case 'A': case 'E': case 'F': case 'G': case 'X':
-		case '[': case 's':
-		case 'p': case 'n':
+		case '[':
 			break;
-		default:
-			goto fmt_fail;
-		}
-
-		if (t == 'n') {
+		case 'n':
 			store_int(dest, size, pos);
 			/* do not increment match count, etc! */
 			continue;
-		}
-
-		if (t != '[' && (t|32) != 'c') {
+		default:
 			shlim(f, 0);
 			while (isspace(shgetc(f)));
 			shunget(f);
-- 
1.7.2.5


From de80ea9f1c2821cbb4205533b86d5d17f9e8d376 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Wed, 5 Jun 2013 16:53:26 -0400
Subject: [PATCH 40/53] refactor wide-char scanf string handling

this brings the wide version of the code into alignment with the
byte-based version, in preparation for adding support for the m
(malloc) modifier.
---
 src/stdio/vfwscanf.c |   87 ++++++++++++++++++-------------------------------
 1 files changed, 32 insertions(+), 55 deletions(-)

diff --git a/src/stdio/vfwscanf.c b/src/stdio/vfwscanf.c
index 44910b4..45de337 100644
--- a/src/stdio/vfwscanf.c
+++ b/src/stdio/vfwscanf.c
@@ -102,6 +102,7 @@ int vfwscanf(FILE *restrict f, const wchar_t *restrict fmt, va_list ap)
 	off_t pos = 0, cnt;
 	static const char size_pfx[][3] = { "hh", "h", "", "l", "L", "ll" };
 	char tmp[3*sizeof(int)+10];
+	const wchar_t *set;
 
 	FLOCK(f);
 
@@ -179,8 +180,11 @@ int vfwscanf(FILE *restrict f, const wchar_t *restrict fmt, va_list ap)
 
 		t = *p;
 
-		/* Transform ls,lc -> S,C */
-		if (size==SIZE_l && (t&15)==3) t&=~32;
+		/* Transform S,C -> ls,lc */
+		if ((t&0x2f)==3) {
+			size = SIZE_l;
+			t |= 32;
+		}
 
 		if (t != 'n') {
 			if (t != '[' && (t|32) != 'c')
@@ -197,63 +201,41 @@ int vfwscanf(FILE *restrict f, const wchar_t *restrict fmt, va_list ap)
 			/* do not increment match count, etc! */
 			continue;
 
-		case 'c':
-			if (width < 1) width = 1;
-			s = dest;
-			for (; width && (c=getwc(f)) >= 0; width--) {
-				int l = wctomb(s?s:tmp, c);
-				if (l<0) goto input_fail;
-				if (s) s+=l;
-				pos++;
-			}
-			if (width) goto match_fail;
-			break;
-
-		case 'C':
-			if (width < 1) width = 1;
-			wcs = dest;
-			for (; width && (c=getwc(f)) >= 0; width--)
-				pos++, wcs && (*wcs++ = c);
-			if (width) goto match_fail;
-			break;
-
 		case 's':
-			if (width < 1) width = -1;
-			s = dest;
-			while (width && !iswspace(c=getwc(f)) && c!=EOF) {
-				int l = wctomb(s?s:tmp, c);
-				if (l<0) goto input_fail;
-				if (s) s+=l;
-				pos++;
-				width-=(width>0);
+		case 'c':
+		case '[':
+			if (t == 'c') {
+				if (width<1) width = 1;
+				invert = 1;
+				set = L"";
+			} else if (t == 's') {
+				invert = 1;
+				set = (const wchar_t[]){
+					' ', '\t', '\n', '\r', 11, 12,  0x0085,
+					0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005,
+					0x2006, 0x2008, 0x2009, 0x200a,
+					0x2028, 0x2029, 0x205f, 0x3000, 0 };
+			} else {
+				if (*++p == '^') p++, invert = 1;
+				else invert = 0;
+				set = p;
+				if (*p==']') p++;
+				while (*p!=']') {
+					if (!*p) goto fmt_fail;
+					p++;
+				}
 			}
-			if (width) ungetwc(c, f);
-			if (s) *s = 0;
-			break;
-
-		case 'S':
-			wcs = dest;
-			if (width < 1) width = -1;
-			while (width && !iswspace(c=getwc(f)) && c!=EOF)
-				width-=(width>0), pos++, *wcs++ = c;
-			if (width) ungetwc(c, f);
-			if (wcs) *wcs = 0;
-			break;
 
-		case '[':
 			s = (size == SIZE_def) ? dest : 0;
 			wcs = (size == SIZE_l) ? dest : 0;
 
-			if (*++p == '^') p++, invert = 1;
-			else invert = 0;
-
 			int gotmatch = 0;
 
 			if (width < 1) width = -1;
 
 			while (width) {
 				if ((c=getwc(f))<0) break;
-				if (in_set(p, c) == invert)
+				if (in_set(set, c) == invert)
 					break;
 				if (wcs) {
 					*wcs++ = c;
@@ -266,14 +248,9 @@ int vfwscanf(FILE *restrict f, const wchar_t *restrict fmt, va_list ap)
 				width-=(width>0);
 				gotmatch=1;
 			}
-			if (width) ungetwc(c, f);
-
-			if (!gotmatch) goto match_fail;
-
-			if (*p==']') p++;
-			while (*p!=']') {
-				if (!*p) goto fmt_fail;
-				p++;
+			if (width) {
+				ungetwc(c, f);
+				if (t == 'c' || !gotmatch) goto match_fail;
 			}
 
 			if (wcs) *wcs++ = 0;
-- 
1.7.2.5


From 16a1e0365d83c387d0dddd3c127ac7c8dcdf17fc Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Wed, 5 Jun 2013 18:18:41 -0400
Subject: [PATCH 41/53] implement the 'm' (malloc) modifier for scanf

this commit only covers the byte-based scanf-family functions. the
wide functions still lack support for the 'm' modifier.
---
 src/stdio/vfscanf.c |   70 +++++++++++++++++++++++++++++++++++----------------
 1 files changed, 48 insertions(+), 22 deletions(-)

diff --git a/src/stdio/vfscanf.c b/src/stdio/vfscanf.c
index d8f9ae6..6bea6ad 100644
--- a/src/stdio/vfscanf.c
+++ b/src/stdio/vfscanf.c
@@ -56,21 +56,6 @@ static void *arg_n(va_list ap, unsigned int n)
 	return p;
 }
 
-static int readwc(int c, wchar_t **wcs, mbstate_t *st)
-{
-	char ch = c;
-	wchar_t wc;
-	switch (mbrtowc(&wc, &ch, 1, st)) {
-	case -1:
-		return -1;
-	case -2:
-		break;
-	default:
-		if (*wcs) *(*wcs)++ = wc;
-	}
-	return 0;
-}
-
 int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 {
 	int width;
@@ -89,6 +74,8 @@ int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 	long double y;
 	off_t pos = 0;
 	unsigned char scanset[257];
+	size_t i, k;
+	wchar_t wc;
 
 	FLOCK(f);
 
@@ -129,7 +116,7 @@ int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 		}
 
 		if (*p=='m') {
-			alloc = 1;
+			alloc = !!dest;
 			p++;
 		} else {
 			alloc = 0;
@@ -227,25 +214,59 @@ int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 			}
 			wcs = 0;
 			s = 0;
+			i = 0;
+			k = t=='c' ? width+1U : 31;
 			if (size == SIZE_l) {
-				wcs = dest;
+				if (alloc) {
+					wcs = malloc(k*sizeof(wchar_t));
+					if (!wcs) goto alloc_fail;
+				} else {
+					wcs = dest;
+				}
 				st = (mbstate_t){0};
 				while (scanset[(c=shgetc(f))+1]) {
-					if (readwc(c, &wcs, &st) < 0)
+					switch (mbrtowc(&wc, &(char){c}, 1, &st)) {
+					case -1:
 						goto input_fail;
+					case -2:
+						continue;
+					}
+					if (wcs) wcs[i++] = wc;
+					if (alloc && i==k) {
+						k+=k+1;
+						wchar_t *tmp = realloc(wcs, k*sizeof(wchar_t));
+						if (!tmp) goto alloc_fail;
+						wcs = tmp;
+					}
 				}
 				if (!mbsinit(&st)) goto input_fail;
+			} else if (alloc) {
+				s = malloc(k);
+				if (!s) goto alloc_fail;
+				while (scanset[(c=shgetc(f))+1]) {
+					s[i++] = c;
+					if (i==k) {
+						k+=k+1;
+						char *tmp = realloc(s, k);
+						if (!tmp) goto alloc_fail;
+						s = tmp;
+					}
+				}
 			} else if ((s = dest)) {
 				while (scanset[(c=shgetc(f))+1])
-					*s++ = c;
+					s[i++] = c;
 			} else {
 				while (scanset[(c=shgetc(f))+1]);
 			}
 			shunget(f);
 			if (!shcnt(f)) goto match_fail;
 			if (t == 'c' && shcnt(f) != width) goto match_fail;
-			if (wcs) *wcs = 0;
-			if (s) *s = 0;
+			if (alloc) {
+				if (size == SIZE_l) *(wchar_t **)dest = wcs;
+				else *(char **)dest = s;
+			}
+			if (wcs) wcs[i] = 0;
+			if (s) s[i] = 0;
 			break;
 		case 'p':
 		case 'X':
@@ -292,10 +313,15 @@ int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 	}
 	if (0) {
 fmt_fail:
+alloc_fail:
 input_fail:
 		if (!matches) matches--;
-	}
 match_fail:
+		if (alloc) {
+			free(s);
+			free(wcs);
+		}
+	}
 	FUNLOCK(f);
 	return matches;
 }
-- 
1.7.2.5


From e039db27c2b4298470861c57535eb91a3eb3b1a6 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Thu, 6 Jun 2013 00:26:17 -0400
Subject: [PATCH 42/53] implement 'm' modifier for wide scanf variants

---
 src/stdio/vfwscanf.c |   47 ++++++++++++++++++++++++++++++++++++++++-------
 1 files changed, 40 insertions(+), 7 deletions(-)

diff --git a/src/stdio/vfwscanf.c b/src/stdio/vfwscanf.c
index 45de337..b1eb793 100644
--- a/src/stdio/vfwscanf.c
+++ b/src/stdio/vfwscanf.c
@@ -103,6 +103,7 @@ int vfwscanf(FILE *restrict f, const wchar_t *restrict fmt, va_list ap)
 	static const char size_pfx[][3] = { "hh", "h", "", "l", "L", "ll" };
 	char tmp[3*sizeof(int)+10];
 	const wchar_t *set;
+	size_t i, k;
 
 	FLOCK(f);
 
@@ -140,7 +141,7 @@ int vfwscanf(FILE *restrict f, const wchar_t *restrict fmt, va_list ap)
 		}
 
 		if (*p=='m') {
-			alloc = 1;
+			alloc = !!dest;
 			p++;
 		} else {
 			alloc = 0;
@@ -233,16 +234,39 @@ int vfwscanf(FILE *restrict f, const wchar_t *restrict fmt, va_list ap)
 
 			if (width < 1) width = -1;
 
+			i = 0;
+			if (alloc) {
+				k = t=='c' ? width+1U : 31;
+				if (size == SIZE_l) {
+					wcs = malloc(k*sizeof(wchar_t));
+					if (!wcs) goto alloc_fail;
+				} else {
+					s = malloc(k);
+					if (!s) goto alloc_fail;
+				}
+			}
 			while (width) {
 				if ((c=getwc(f))<0) break;
 				if (in_set(set, c) == invert)
 					break;
 				if (wcs) {
-					*wcs++ = c;
+					wcs[i++] = c;
+					if (alloc && i==k) {
+						k += k+1;
+						wchar_t *tmp = realloc(wcs, k*sizeof(wchar_t));
+						if (!tmp) goto alloc_fail;
+						wcs = tmp;
+					}
 				} else if (size != SIZE_l) {
-					int l = wctomb(s?s:tmp, c);
+					int l = wctomb(s?s+i:tmp, c);
 					if (l<0) goto input_fail;
-					if (s) s+=l;
+					i += l;
+					if (alloc && i > k-4) {
+						k += k+1;
+						char *tmp = realloc(s, k);
+						if (!tmp) goto alloc_fail;
+						s = tmp;
+					}
 				}
 				pos++;
 				width-=(width>0);
@@ -253,8 +277,12 @@ int vfwscanf(FILE *restrict f, const wchar_t *restrict fmt, va_list ap)
 				if (t == 'c' || !gotmatch) goto match_fail;
 			}
 
-			if (wcs) *wcs++ = 0;
-			if (s) *s++ = 0;
+			if (alloc) {
+				if (size == SIZE_l) *(wchar_t **)dest = wcs;
+				else *(char **)dest = s;
+			}
+			if (wcs) wcs[i] = 0;
+			if (s) s[i] = 0;
 			break;
 
 		case 'd': case 'i': case 'o': case 'u': case 'x':
@@ -279,10 +307,15 @@ int vfwscanf(FILE *restrict f, const wchar_t *restrict fmt, va_list ap)
 	}
 	if (0) {
 fmt_fail:
+alloc_fail:
 input_fail:
 		if (!matches) matches--;
-	}
 match_fail:
+		if (alloc) {
+			free(s);
+			free(wcs);
+		}
+	}
 	FUNLOCK(f);
 	return matches;
 }
-- 
1.7.2.5


From f7244d205fc68d9ee8e28f89a8b5a680586a6117 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 7 Jun 2013 09:54:45 -0400
Subject: [PATCH 43/53] improve handling of nonstandard fields in struct tm

defining tm_gmtoff and tm_zone as macros was breaking some application
code that used these names for its own purposes.
---
 include/time.h |    9 +++++----
 1 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/include/time.h b/include/time.h
index aa4efff..09a65cf 100644
--- a/include/time.h
+++ b/include/time.h
@@ -25,6 +25,11 @@ extern "C" {
 
 #include <bits/alltypes.h>
 
+#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
+#define __tm_gmtoff tm_gmtoff
+#define __tm_zone tm_zone
+#endif
+
 struct tm
 {
 	int tm_sec;
@@ -39,10 +44,6 @@ struct tm
 	long __tm_gmtoff;
 	const char *__tm_zone;
 };
-#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
-#define tm_gmtoff __tm_gmtoff
-#define tm_zone __tm_zone
-#endif
 
 clock_t clock (void);
 time_t time (time_t *);
-- 
1.7.2.5


From c161356002354f238a3333cafab430ada5006269 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 7 Jun 2013 10:13:07 -0400
Subject: [PATCH 44/53] make gcc-specific headers (intrinsics, etc.) available with wrapper

they are intentionally listed after the libc include directory so that
the gcc float.h, etc. don't get used in place of the libc ones.
---
 tools/musl-gcc.specs.sh |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/tools/musl-gcc.specs.sh b/tools/musl-gcc.specs.sh
index 3e88c5d..1f683ce 100644
--- a/tools/musl-gcc.specs.sh
+++ b/tools/musl-gcc.specs.sh
@@ -5,10 +5,10 @@ cat <<EOF
 %rename cpp_options old_cpp_options
 
 *cpp_options:
--nostdinc -isystem $incdir %(old_cpp_options)
+-nostdinc -isystem $incdir -isystem include%s %(old_cpp_options)
 
 *cc1:
-%(cc1_cpu) -nostdinc -isystem $incdir 
+%(cc1_cpu) -nostdinc -isystem -isystem include%s $incdir 
 
 *link_libgcc:
 -L$libdir -L .%s
-- 
1.7.2.5


From fd1d7be35f1b7f083071e246208498aa3b5ced3e Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Fri, 7 Jun 2013 10:18:07 -0400
Subject: [PATCH 45/53] fix mixup in previous change to gcc wrapper

---
 tools/musl-gcc.specs.sh |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/tools/musl-gcc.specs.sh b/tools/musl-gcc.specs.sh
index 1f683ce..294e24f 100644
--- a/tools/musl-gcc.specs.sh
+++ b/tools/musl-gcc.specs.sh
@@ -8,7 +8,7 @@ cat <<EOF
 -nostdinc -isystem $incdir -isystem include%s %(old_cpp_options)
 
 *cc1:
-%(cc1_cpu) -nostdinc -isystem -isystem include%s $incdir 
+%(cc1_cpu) -nostdinc -isystem $incdir -isystem include%s
 
 *link_libgcc:
 -L$libdir -L .%s
-- 
1.7.2.5


From c79cd27e9e81eb5e223728094f1233ee2fc12dda Mon Sep 17 00:00:00 2001
From: Szabolcs Nagy <nsz@port70.net>
Date: Sat, 8 Jun 2013 13:31:10 +0000
Subject: [PATCH 46/53] prng: fix rand() to give good sequence with small state

some applications rely on the low bits of rand() to be reasonably good
quality prng, so now it fixed by using the top bits of a 64 bit LCG,
this is simple, has small state and passes statistical tests.
D.E. Knuth attributes the multiplier to C.E. Haynes in TAOCP Vol2 3.3.4
---
 src/prng/rand.c |    6 ++++--
 1 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/prng/rand.c b/src/prng/rand.c
index e3ce634..c000cd2 100644
--- a/src/prng/rand.c
+++ b/src/prng/rand.c
@@ -1,6 +1,7 @@
 #include <stdlib.h>
+#include <stdint.h>
 
-static unsigned seed;
+static uint64_t seed;
 
 void srand(unsigned s)
 {
@@ -9,5 +10,6 @@ void srand(unsigned s)
 
 int rand(void)
 {
-	return (seed = (seed+1) * 1103515245 + 12345 - 1)+1 & 0x7fffffff;
+	seed = 6364136223846793005ULL*seed + 1;
+	return seed>>33;
 }
-- 
1.7.2.5


From 0996faa3d789dd69e4c1c022757f0623908b0df5 Mon Sep 17 00:00:00 2001
From: Szabolcs Nagy <nsz@port70.net>
Date: Sat, 8 Jun 2013 13:49:12 +0000
Subject: [PATCH 47/53] prng: make rand_r have 2^32 period instead of 2^31

this is a minor fix to increase the period of the obsolete rand_r a bit.
an include header in __rand48_step.c is fixed as well.
---
 src/prng/__rand48_step.c |    2 +-
 src/prng/rand_r.c        |    2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/prng/__rand48_step.c b/src/prng/__rand48_step.c
index 755b4f2..105f810 100644
--- a/src/prng/__rand48_step.c
+++ b/src/prng/__rand48_step.c
@@ -1,5 +1,5 @@
 #include <stdlib.h>
-#include <inttypes.h>
+#include <stdint.h>
 
 uint64_t __rand48_step(unsigned short *xi, unsigned short *lc)
 {
diff --git a/src/prng/rand_r.c b/src/prng/rand_r.c
index e96cfba..ef26dbd 100644
--- a/src/prng/rand_r.c
+++ b/src/prng/rand_r.c
@@ -2,5 +2,5 @@
 
 int rand_r(unsigned *seed)
 {
-	return (*seed = *seed * 1103515245 + 12345) & 0x7fffffff;
+	return (*seed = *seed * 1103515245 + 12345)/2;
 }
-- 
1.7.2.5


From ea200e38bd79723054c7ad97cbf87911eac5b7f5 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sat, 8 Jun 2013 11:36:41 -0400
Subject: [PATCH 48/53] support cputime clocks for processes/threads other than self

apparently these features have been in Linux for a while now, so it
makes sense to support them. the bit twiddling seems utterly illogical
and wasteful, especially the negation, but that's how the kernel folks
chose to encode pids/tids into the clock id.
---
 src/thread/pthread_getcpuclockid.c |    3 ++-
 src/time/clock_getcpuclockid.c     |    7 +++++--
 2 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/thread/pthread_getcpuclockid.c b/src/thread/pthread_getcpuclockid.c
index cf3d2b8..9df14fb 100644
--- a/src/thread/pthread_getcpuclockid.c
+++ b/src/thread/pthread_getcpuclockid.c
@@ -2,5 +2,6 @@
 
 int pthread_getcpuclockid(pthread_t t, clockid_t *clockid)
 {
-	return ENOSYS;
+	*clockid = (-t->tid-1)*8U + 6;
+	return 0;
 }
diff --git a/src/time/clock_getcpuclockid.c b/src/time/clock_getcpuclockid.c
index 723840b..8a0e2d4 100644
--- a/src/time/clock_getcpuclockid.c
+++ b/src/time/clock_getcpuclockid.c
@@ -5,7 +5,10 @@
 
 int clock_getcpuclockid(pid_t pid, clockid_t *clk)
 {
-	if (pid && pid != getpid()) return EPERM;
-	*clk = CLOCK_PROCESS_CPUTIME_ID;
+	struct timespec ts;
+	clockid_t id = (-pid-1)*8U + 2;
+	int ret = __syscall(SYS_clock_getres, id, &ts);
+	if (ret) return -ret;
+	*clk = id;
 	return 0;
 }
-- 
1.7.2.5


From 01739902843e93ec6e9bf8e17d32c8ddf73fad81 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sat, 8 Jun 2013 11:40:27 -0400
Subject: [PATCH 49/53] fix the type of CLOCKS_PER_SEC to match new clock_t type

originally it was right on 32-bit archs and wrong on 64-bit, but after
recent changes it was wrong everywhere. with this commit, it's now
right everywhere.
---
 include/time.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/include/time.h b/include/time.h
index 09a65cf..56ffacf 100644
--- a/include/time.h
+++ b/include/time.h
@@ -55,7 +55,7 @@ struct tm *localtime (const time_t *);
 char *asctime (const struct tm *);
 char *ctime (const time_t *);
 
-#define CLOCKS_PER_SEC 1000000UL
+#define CLOCKS_PER_SEC 1000000L
 
 
 #if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
-- 
1.7.2.5


From 4191d2447673e6b03722198871af0daf9390cb51 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sat, 8 Jun 2013 11:42:52 -0400
Subject: [PATCH 50/53] add clock id macros for a number of new(ish) Linux-specific clocks

arguably CLOCK_MONOTONIC should be redirected to CLOCK_BOOTTIME with a
fallback for old kernels that don't support it, since Linux's
CLOCK_BOOTTIME semantics seem to match the spirit of the POSIX
requirements for CLOCK_MONOTONIC better than Linux's version of
CLOCK_MONOTONIC does. however, this is a change that would require
further discussion and research, so for now, I'm simply making them
all available.
---
 include/time.h |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/include/time.h b/include/time.h
index 56ffacf..5b3dde5 100644
--- a/include/time.h
+++ b/include/time.h
@@ -81,6 +81,12 @@ struct itimerspec
 #define CLOCK_MONOTONIC          1
 #define CLOCK_PROCESS_CPUTIME_ID 2
 #define CLOCK_THREAD_CPUTIME_ID  3
+#define CLOCK_MONOTONIC_RAW      4
+#define CLOCK_REALTIME_COURSE    5
+#define CLOCK_MONOTONIC_COURSE   6
+#define CLOCK_BOOTTIME           7
+#define CLOCK_REALTIME_ALARM     8
+#define CLOCK_BOOTTIME_ALARM     9
 
 #define TIMER_ABSTIME 1
 
-- 
1.7.2.5


From 20d01d83b5a13c77805976e7c520f566244ba3ff Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Wed, 12 Jun 2013 18:20:48 -0400
Subject: [PATCH 51/53] improve the quality of output from rand_r

due to the interface requirement of having the full state contained in
a single object of type unsigned int, it is difficult to provide a
reasonable-quality implementation; most good PRNGs are immediately
ruled out because they need larger state. the old rand_r gave very
poor output (very short period) in its lower bits; normally, it's
desirable to throw away the low bits (as in rand()) when using a LCG,
but this is not possible since the state is only 32 bits and we need
31 bits of output.

glibc's rand_r uses the same LCG as musl's, but runs it for 3
iterations and only takes 10-11 bits from each iteration to construct
the output value. this partially fixes the period issue, but
introduces bias: not all outputs have the same frequency, and many do
not appear at all. with such a low period, the bias is likely to be
observable.

I tried many approaches to "fix" rand_r, and the simplest I found
which made it pass the "dieharder" tests was applying this
transformation to the output. the "temper" function is taken from
mersenne twister, where it seems to have been chosen for some rigorous
properties; here, the only formal property I'm using is that it's
one-to-one and thus avoids introducing bias.

should further deficiencies in rand_r be reported, the obvious "best"
solution is applying a 32-bit cryptographic block cipher in CTR mode.
I identified several possible ciphers that could be used directly or
adapted, but as they would be a lot slower and larger, I do not see a
justification for using them unless the current rand_r proves
deficient for some real-world use.
---
 src/prng/rand_r.c |   11 ++++++++++-
 1 files changed, 10 insertions(+), 1 deletions(-)

diff --git a/src/prng/rand_r.c b/src/prng/rand_r.c
index ef26dbd..638614c 100644
--- a/src/prng/rand_r.c
+++ b/src/prng/rand_r.c
@@ -1,6 +1,15 @@
 #include <stdlib.h>
 
+static unsigned temper(unsigned x)
+{
+	x ^= x>>11;
+	x ^= x<<7 & 0x9D2C5680;
+	x ^= x<<15 & 0xEFC60000;
+	x ^= x>>18;
+	return x;
+}
+
 int rand_r(unsigned *seed)
 {
-	return (*seed = *seed * 1103515245 + 12345)/2;
+	return temper(*seed = *seed * 1103515245 + 12345)/2;
 }
-- 
1.7.2.5


From 8600849d74ddd1fca8eba467af5c04c18731ba49 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sun, 16 Jun 2013 01:40:17 -0400
Subject: [PATCH 52/53] fix uninitialized variable in lio (aio) code

---
 src/aio/lio_listio.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/src/aio/lio_listio.c b/src/aio/lio_listio.c
index 64a6ebc..07145dd 100644
--- a/src/aio/lio_listio.c
+++ b/src/aio/lio_listio.c
@@ -13,7 +13,7 @@ struct lio_state {
 
 static int lio_wait(struct lio_state *st)
 {
-	int i, err, got_err;
+	int i, err, got_err = 0;
 	int cnt = st->cnt;
 	struct aiocb **cbs = st->cbs;
 
-- 
1.7.2.5


From a494171a5a2778fc7b4d24d673d950f3e9864063 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Sun, 16 Jun 2013 10:39:02 -0400
Subject: [PATCH 53/53] fix invalid access in aio notification

issue found and patch provided by Jens Gustedt. after the atomic store
to the error code field of the aiocb, the application is permitted to
free or reuse the storage, so further access is invalid. instead, use
the local copy that was already made.
---
 src/aio/aio_readwrite.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/src/aio/aio_readwrite.c b/src/aio/aio_readwrite.c
index e4c95aa..666372d 100644
--- a/src/aio/aio_readwrite.c
+++ b/src/aio/aio_readwrite.c
@@ -51,7 +51,7 @@ static void *io_thread(void *p)
 
 	__aio_wake();
 
-	switch (cb->aio_sigevent.sigev_notify) {
+	switch (sev.sigev_notify) {
 	case SIGEV_SIGNAL:
 		notify_signal(&sev);
 		break;
-- 
1.7.2.5

